<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=720, initial-scale=1.0">
  <title>–ü–†–ò–ö–õ–Æ–ß–ï–ù–ò–Ø –°–û–§–ò–ò</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body {
      background: #fff; /* page background is white */
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: 'Press Start 2P', cursive;
      margin: 0;
      padding: 0;
    }
    #gameContainer {
      position: relative;
      width: 720px;
      height: 240px;
      background: linear-gradient(to bottom, #2196f3 0%, #b3e5fc 100%); /* blue sky gradient */
      border: 2px solid #333;
      overflow: hidden;
      margin-top: 40px;
      box-shadow: 0 4px 24px 0 rgba(63,69,81,0.16);
      /* Safari performance optimizations */
      -webkit-transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      -webkit-perspective: 1000;
    }
    #gameContainer.dark {
      background: #222;
    }
    #gameContainer.night {
      background: linear-gradient(to bottom, #070b1f 0%, #0a0f2e 15%, #0d1847 35%, #2d1b69 65%, #4a1a6b 85%, #6b2c5c 100%);
    }
    #nightOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, #070b1f 0%, #0a0f2e 15%, #0d1847 35%, #2d1b69 65%, #4a1a6b 85%, #6b2c5c 100%);
      opacity: 0;
      transition: opacity 3s ease-in-out;
      pointer-events: none;
      z-index: 0;
    }
    #nightOverlay.active {
      opacity: 1;
    }
    #player {
      position: absolute;
      left: 60px;
      bottom: 24px;
      width: 72px;
      height: 72px;
      object-fit: contain;
      image-rendering: pixelated;
      user-select: none;
      pointer-events: none;
      /* Safari performance optimizations */
      -webkit-transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      will-change: transform;
    }
    .obstacle {
      position: absolute;
      bottom: 24px;
      width: 24px;
      height: 48px;
      /* Safari performance optimizations */
      -webkit-transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      will-change: transform;
    }
    .obstacle.gif {
      width: 36px !important;
      height: 72px !important;
      bottom: 24px;
    }
    .obstacle:not(img) {
      background: #e53935;
      border-radius: 4px;
    }
    #ground {
      position: absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 24px;
      background: #bbb; /* lighter grey road */
      transition: background 3s ease-in-out; /* Match day/night transition duration */
    }
    #gameContainer.dark #ground {
      background: #666;
    }
    #score, #gameOver, h1, p, #highScore {
      color: #ff69b4 !important; /* bright pink */
      transition: color 3s ease-in-out; /* Match day/night transition duration */
    }
    #gameOver {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.95);
      padding: 24px 40px;
      border: 2px solid #ff69b4; /* bright pink border */
      border-radius: 8px;
      font-size: 1.5em;
      z-index: 10;
      text-align: center;
    }
    #gameContainer.dark #gameOver {
      background: rgba(34,34,34,0.95);
      border-color: #ff69b4;
    }
    button {
      margin-top: 16px;
      padding: 8px 20px;
      font-size: 1em;
      border-radius: 6px;
      border: 1px solid #333;
      background: #fff;
      cursor: pointer;
    }
    button:hover {
      background: #eee;
    }
    .obstacle.special {
      width: 48px !important;
      height: 48px !important;
      object-fit: contain;
      image-rendering: pixelated;
      bottom: 24px !important;
    }
    .scissors-bird {
      pointer-events: none;
      user-select: none;
      image-rendering: pixelated;
      transition: filter 0.3s;
    }
    .styled-btn {
      font-family: 'Press Start 2P', cursive;
      font-size: 1em;
      color: #2196f3;
      background: #fff;
      border: 2px solid #2196f3;
      border-radius: 8px;
      padding: 8px 18px;
      margin: 0;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
      outline: none;
      box-shadow: 0 2px 8px 0 rgba(33,150,243,0.08);
      letter-spacing: 1px;
    }
    .styled-btn:hover, .styled-btn:focus {
      background: #e3f2fd;
      color: #1565c0;
    }
    .obstacle.png5 { image-rendering: pixelated; object-fit: contain; }
    .obstacle.png6 { image-rendering: pixelated; object-fit: contain; }
  </style>
</head>
<body>
  <h1>–ü–†–ò–ö–õ–Æ–ß–ï–ù–ò–Ø –°–û–§–ò–ò</h1>
  <div id="highScore" style="color:#ff69b4;margin-bottom:8px;">–õ—É—á—à–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: 0</div>
  <div id="score">–°—á—ë—Ç: 0</div>
  <div id="speed" style="color:#2196f3;margin-bottom:20px;margin-top:8px;">–°–∫–æ—Ä–æ—Å—Ç—å: 0.0</div>
  <div id="loading" style="font-family:'Press Start 2P',cursive;font-size:1.2em;color:#2196f3;margin-top:40px;">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
  <div id="gameContainer">
    <div id="nightOverlay"></div>
    <canvas id="stars" width="720" height="240" style="position:absolute;left:0;top:0;pointer-events:none;z-index:1;"></canvas>
    <img id="player" src="https://i.postimg.cc/dtBqYwh3/Pixelion.png" alt="–ò–≥—Ä–æ–∫" style="z-index:2;position:absolute;" />
    <canvas id="groundCanvas" width="720" height="24" style="z-index:3;position:absolute;left:0;bottom:0;"></canvas>
    <div id="gameOver" style="z-index:4;position:absolute;">
      –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!<br>
      <button onclick="restartGame()">–ó–∞–Ω–æ–≤–æ</button>
    </div>
  </div>
  <div style="margin-top:16px; display:flex; gap:12px; align-items:center;">
    <button id="soundsToggle" class="styled-btn">üîä –ó–≤—É–∫–∏: –í–∫–ª</button>
    <button id="soundToggle" class="styled-btn">üéµ –ú—É–∑—ã–∫–∞: –í—ã–∫–ª</button>
  </div>
  <audio id="loseSound" src="https://dl.dropboxusercontent.com/scl/fi/03ewjm0np47rvxwvkw4fr/080047_lose_funny_retro_video-game-80925.mp3?rlkey=f5sz95h1alf549ppriqkv7ees&st=8t37iozp" preload="auto"></audio>
  <audio id="gameMusic" src="https://dl.dropboxusercontent.com/scl/fi/u8vy9c7rk8uh86l4iy2ef/Swan-Lake-Theme.mp3?rlkey=c9gl4gd9i4jy5f25esiqd1ra3&st=jla22prl" loop preload="auto"></audio>
  <audio id="jumpSound" src="https://dl.dropboxusercontent.com/scl/fi/ezrm6z3cx6zia9ski74nd/retro-jump-1-236684.mp3?rlkey=cbxvo5jhokcw9f68d4plxeuuf&st=b95r8mro" preload="auto"></audio>
  <p>–ù–∞–∂–º–∏—Ç–µ <b>–ü—Ä–æ–±–µ–ª</b> –∏–ª–∏ <b>–°—Ç—Ä–µ–ª–∫—É –≤–≤–µ—Ä—Ö</b>, —á—Ç–æ–±—ã –ø—Ä—ã–≥–Ω—É—Ç—å.</p>
  <script>
    const gameContainer = document.getElementById('gameContainer');
    const player = document.getElementById('player');
    const scoreDisplay = document.getElementById('score');
    const highScoreDisplay = document.getElementById('highScore');
    const gameOverDisplay = document.getElementById('gameOver');
    const groundCanvas = document.getElementById('groundCanvas');
    const groundCtx = groundCanvas.getContext('2d');
    let groundOffset = 0;
    const h1 = document.querySelector('h1');
    const p = document.querySelector('p');
    const starsCanvas = document.getElementById('stars');
    const starsCtx = starsCanvas.getContext('2d');
    let stars = [];
    const nightOverlay = document.getElementById('nightOverlay');

    // Game settings
    const gravity = 0.6;
    const jumpStrength = 14; // slightly lower jump
    let obstacleSpeed = 3; // starting speed changed to 3
    let nextObstacleInterval = 1320 + Math.random() * 1080; // random between 1320-2400ms (20% less frequent)
    const groundY = 24;
    const playerSize = 72;
    let playerY = groundY;
    let velocityY = 0;
    let isJumping = false;
    let isGameOver = false;
    let score = 0;
    let obstacles = [];
    let obstacleTimer = 0;
    let lastTime = null;
    let animationId = null;
    let gifObstaclesCount = 0;
    let darkMode = false;

    // Safari performance optimizations
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    const performanceMultiplier = isSafari ? 0.9 : 1.0; // Slightly reduce spawn rate for Safari

    // Character images
    const playerStandingImg = "https://i.postimg.cc/dtBqYwh3/Pixelion.png";
    const playerRunningImg = "https://i.postimg.cc/DyDdLcHT/ezgif-com-optimize.gif";
    const playerJumpingImg = "https://i.postimg.cc/GpBrGDqT/Pixelion-2.png";

    // Sky overlay image for day and night
    const skyOverlayImg = new Image();
    skyOverlayImg.src = 'https://i.postimg.cc/Fzz3Jfxz/13-1.png';

    // Night stars overlay image
    const nightStarsImg = new Image();
    nightStarsImg.src = 'https://i.postimg.cc/pThkg1gq/18.png';

    // New obstacle images
    const obstacleImages = [
      'https://i.postimg.cc/vHNFnpGZ/16.png',
      'https://i.postimg.cc/8CLqqcM7/15.png',
      'https://i.postimg.cc/85DqDGmt/Pixelion-7.png',
      'https://i.postimg.cc/FzwprgQN/17.png'
    ];

    // --- FLYING SCISSORS (BIRDS) ---
    let scissors = [];
    const scissorsImg = 'https://i.postimg.cc/NM6G70K8/ezgif-com-animated-gif-maker.gif';
    let scissorsTimer = 0;
    let scissorsStartScore = null;
    let nextScissorsInterval = 5000 + Math.random() * 5000; // 5-10 seconds at first

    // Helper to check if a new scissors would overlap with any ground obstacle
    function isScissorsSafe(x, width) {
      const safetyMargin = 200; // extremely large margin to prevent any overlap or close proximity
      for (const obs of obstacles) {
        // Only check obstacles that are still on screen
        if (obs.x + obs.width < 0) continue;
        // If the scissors would overlap horizontally with an obstacle (with margin), return false
        if (x < obs.x + obs.width + safetyMargin && x + width > obs.x - safetyMargin) {
          return false;
        }
      }
      return true;
    }

    function spawnScissors() {
      // Only spawn if score >= 200
      if (score < 200) return;
      if (scissorsStartScore === null) scissorsStartScore = score;
      const width = Math.round(54 * 1.3); // 30% bigger
      const height = Math.round(36 * 1.3); // 30% bigger
      let x = gameContainer.offsetWidth;
      // Try up to 5 times to find a safe spawn position
      let safe = false;
      for (let tries = 0; tries < 5; tries++) {
        if (isScissorsSafe(x, width)) {
          safe = true;
          break;
        }
        x += 40; // move further right if not safe
      }
      if (!safe) return; // skip spawning if can't find a safe spot
      const sc = document.createElement('img');
      sc.src = scissorsImg;
      sc.className = 'scissors-bird';
      sc.style.position = 'absolute';
      sc.style.width = width + 'px';
      sc.style.height = height + 'px';
      sc.style.left = x + 'px';
      // Altitude: high (80% chance) or low (20% chance, but even lower)
      let altitude;
      if (Math.random() < 0.8) {
        altitude = 160 + Math.random() * 20; // high: 160-180 px from bottom
      } else {
        altitude = 60 + Math.random() * 20; // low: 60-80 px from bottom
      }
      sc.style.bottom = altitude + 'px';
      sc.style.zIndex = 2;
      gameContainer.appendChild(sc);
      scissors.push({ el: sc, x: x, y: altitude, width, height });
      // Set next spawn interval
      if (scissorsStartScore !== null && score - scissorsStartScore < 100) {
        // Early: 5-10 seconds (reduced from 9-15)
        nextScissorsInterval = 5000 + Math.random() * 5000;
      } else {
        // After 100 points since scissors started: 5-10 seconds (same as early)
        nextScissorsInterval = 5000 + Math.random() * 5000;
      }
    }

    function updateScissors(delta) {
      scissors.forEach(sc => {
        sc.x -= (obstacleSpeed + 1.5) * (delta / 16.67); // Make frame-rate dependent
        if (isSafari) {
          // Use transform for better Safari performance
          sc.el.style.transform = `translateX(${sc.x}px)`;
        } else {
          sc.el.style.left = sc.x + 'px';
        }
      });
      for (let i = scissors.length - 1; i >= 0; i--) {
        const sc = scissors[i];
        if (checkScissorsCollision(sc)) {
          endGame();
          return;
        }
        if (sc.x + sc.width < 0) {
          sc.el.remove();
          scissors.splice(i, 1);
        }
      }
    }

    function checkScissorsCollision(sc) {
      const playerRect = {
        x: 60,
        y: playerY,
        width: playerSize,
        height: playerSize
      };
      // Shrink the scissors hitbox to 55% (45% margin on all sides)
      const marginX = sc.width * 0.45;
      const marginY = sc.height * 0.45;
      const scRect = {
        x: sc.x + marginX,
        y: sc.y + marginY,
        width: sc.width - 2 * marginX,
        height: sc.height - 2 * marginY
      };
      return (
        playerRect.x < scRect.x + scRect.width &&
        playerRect.x + playerRect.width > scRect.x &&
        playerRect.y < scRect.y + scRect.height &&
        playerRect.y + playerRect.height > scRect.y
      );
    }

    const speedDisplay = document.getElementById('speed');
    const soundToggleBtn = document.getElementById('soundToggle');
    const soundsToggleBtn = document.getElementById('soundsToggle');
    const gameMusic = document.getElementById('gameMusic');
    const loseSound = document.getElementById('loseSound');
    const jumpSound = document.getElementById('jumpSound');
    let soundOn = false;
    let soundsOn = true;
    let highScore = 0;
    
    // Load music state and high score from localStorage with proper error handling
    try {
      const savedSoundOn = localStorage.getItem('musicOn');
      if (savedSoundOn !== null) {
        soundOn = savedSoundOn === 'true';
      }
      const savedHighScore = localStorage.getItem('highScore');
      if (savedHighScore !== null) {
        highScore = parseInt(savedHighScore) || 0;
      }
    } catch (e) {
      console.warn('Could not access localStorage:', e);
    }
    
    // Ensure sounds follow music state on initialization
    if (!soundOn) {
      soundsOn = false;
    }
    
    updateMusicButton();
    updateSoundsButton();
    updateHighScoreDisplay();
    
    function updateMusicButton() {
      if (soundToggleBtn) {
        soundToggleBtn.textContent = soundOn ? 'üéµ –ú—É–∑—ã–∫–∞: –í–∫–ª' : 'üéµ –ú—É–∑—ã–∫–∞: –í—ã–∫–ª';
      }
    }
    
    function updateSoundsButton() {
      if (soundsToggleBtn) {
        soundsToggleBtn.textContent = soundsOn ? 'üîä –ó–≤—É–∫–∏: –í–∫–ª' : 'üîä –ó–≤—É–∫–∏: –í—ã–∫–ª';
      }
    }

    function updateHighScoreDisplay() {
      if (highScoreDisplay) {
        highScoreDisplay.textContent = '–õ—É—á—à–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: ' + Math.floor(highScore);
      }
    }

    function updateHighScore(currentScore) {
      if (currentScore > highScore) {
        highScore = currentScore;
        updateHighScoreDisplay();
        try {
          localStorage.setItem('highScore', highScore.toString());
        } catch (e) {
          console.warn('Could not save high score to localStorage:', e);
        }
      }
    }

    function startBackgroundMusic() {
      if (soundOn && gameMusic) {
        gameMusic.currentTime = 0;
        gameMusic.play().catch(e => {
          console.warn('Could not play background music:', e);
        });
      }
    }

    function stopBackgroundMusic() {
      if (gameMusic) {
        gameMusic.pause();
      }
    }

    if (soundToggleBtn) {
      soundToggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        soundOn = !soundOn;
        
        // When music is turned off, also turn off sounds
        if (!soundOn) {
          soundsOn = false;
          updateSoundsButton();
        }
        
        updateMusicButton();
        try {
          localStorage.setItem('musicOn', soundOn ? 'true' : 'false');
        } catch (e) {
          console.warn('Could not save to localStorage:', e);
        }
        
        if (gameRunning) {
          if (soundOn) {
            startBackgroundMusic();
          } else {
            stopBackgroundMusic();
          }
        }
      });
    }

    if (soundsToggleBtn) {
      soundsToggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        
        // Only allow sounds to be turned on if music is also on
        if (!soundsOn && !soundOn) {
          // Can't turn sounds on when music is off - do nothing
          return;
        }
        
        soundsOn = !soundsOn;
        updateSoundsButton();
      });
    }

    let gameStarted = false;
    let gameRunning = false;

    function resetGame() {
      generateStars();
      playerY = groundY - 3; // Lifted by 1 pixel (was groundY - 4)
      velocityY = 0;
      isJumping = false;
      isGameOver = false;
      gameStarted = false;
      gameRunning = false;
      score = 0;
      obstacleSpeed = 3;
      if (speedDisplay) {
        speedDisplay.textContent = '–°–∫–æ—Ä–æ—Å—Ç—å: ' + obstacleSpeed.toFixed(1);
      }
      
      // Clean up obstacles
      obstacles.forEach(obs => {
        if (obs.el && obs.el.parentNode) {
          obs.el.remove();
        }
      });
      obstacles = [];
      
      // Clean up scissors
      scissors.forEach(sc => {
        if (sc.el && sc.el.parentNode) {
          sc.el.remove();
        }
      });
      scissors = [];
      scissorsTimer = 0;
      scissorsStartScore = null;
      nextScissorsInterval = 5000 + Math.random() * 5000;
      
      obstacleTimer = 0;
      nextObstacleInterval = 1320 + Math.random() * 1080; // random between 1320-2400ms (20% less frequent)
      lastTime = null;
      gifObstaclesCount = 0;
      darkMode = false;
      
      if (gameOverDisplay) {
        gameOverDisplay.style.display = 'none';
      }
      
      if (player) {
        player.style.bottom = playerY + 'px';
        player.src = playerStandingImg; // Start with standing image
      }
      
      if (scoreDisplay) {
        scoreDisplay.textContent = '–°—á—ë—Ç: 0';
      }
      
      gameContainer.classList.remove('dark', 'night');
      nightOverlay.classList.remove('active');
      if (h1) h1.style.color = '#ff69b4';
      if (p) p.style.color = '#ff69b4';
      if (scoreDisplay) scoreDisplay.style.color = '#ff69b4';
      if (highScoreDisplay) highScoreDisplay.style.color = '#ff69b4';
      if (gameOverDisplay) gameOverDisplay.style.color = '#ff69b4';
      
      drawStars();
      groundOffset = 0;
      drawGround();
      
      // Save music state to localStorage
      try {
        localStorage.setItem('musicOn', soundOn ? 'true' : 'false');
      } catch (e) {
        console.warn('Could not save to localStorage:', e);
      }
      
      // Don't start game loop until user presses key
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }

    function startGame() {
      if (!gameStarted) {
        gameStarted = true;
        gameRunning = true;
        if (player) {
          player.src = playerRunningImg; // Switch to running GIF
        }
        if (soundOn) {
          startBackgroundMusic();
        }
        if (!animationId) {
          animationId = requestAnimationFrame(gameLoop);
        }
      }
    }

    function updatePlayerSprite() {
      if (!player) return;
      
      if (!gameRunning) {
        player.src = playerStandingImg;
      } else if (isJumping) {
        player.src = playerJumpingImg;
      } else {
        player.src = playerRunningImg;
      }
    }

    function jump() {
      if (!gameStarted) {
        startGame();
        return;
      }
      
      if (!isJumping && !isGameOver) {
        velocityY = jumpStrength;
        isJumping = true;
        updatePlayerSprite();
        if (soundsOn && jumpSound) {
          try {
            jumpSound.currentTime = 0;
            jumpSound.play().catch(e => {
              console.warn('Could not play jump sound:', e);
            });
          } catch (e) {
            console.warn('Jump sound error:', e);
          }
        }
      }
    }

    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        jump();
      }
    });

    // Add click/touch support for mobile
    gameContainer.addEventListener('click', jump);
    gameContainer.addEventListener('touchstart', (e) => {
      e.preventDefault();
      jump();
    });

    function spawnObstacle() {
      // Only spawn GIF obstacles or new static obstacles
      let useGif = false;
      
      if (gifObstaclesCount < Math.floor((obstacles.length + 1) / 5)) {
        useGif = true;
      } else if (Math.random() < 0.3) { // 30% chance for GIF
        useGif = true;
      }
      
      let obstacle;
      let height, width;
      let randomObstacleIndex = -1; // Initialize for all obstacle types
      
      // Determine if it's night mode
      const period = 200;
      const nightStart = 300;
      const inNight = (score >= nightStart) && (Math.floor((score - nightStart) / period) % 2 === 0);
      
      if (useGif) {
        obstacle = document.createElement('img');
        obstacle.src = inNight
          ? 'https://i.postimg.cc/pdFKwfwx/Pixelion-600-x-1000-1.gif'
          : 'https://i.postimg.cc/s2vTvGb0/Pixelion-600-x-1000.gif';
        obstacle.className = 'obstacle gif';
        height = 72; // Fixed height to avoid distortion
        width = 36;  // Fixed width to maintain aspect ratio
        randomObstacleIndex = -1; // GIF obstacles don't have an index
        gifObstaclesCount++;
      } else {
        // Use one of the new obstacle images randomly
        randomObstacleIndex = Math.floor(Math.random() * obstacleImages.length);
        obstacle = document.createElement('img');
        obstacle.src = obstacleImages[randomObstacleIndex];
        obstacle.className = 'obstacle static';
        
        // Fixed sizes to avoid distortion, maintain aspect ratios
        switch(randomObstacleIndex) {
          case 0: // 16.png
            height = 48;
            width = 32;
            break;
          case 1: // 15.png - 20% bigger
            height = 48; // 40 * 1.2
            width = 48;  // 40 * 1.2
            break;
          case 2: // Pixelion-7.png - Made bigger
            height = 68; // Increased from 56
            width = 44;  // Increased from 36
            break;
          case 3: // 17.png
            height = 44;
            width = 28;
            break;
          default:
            height = 48;
            width = 32;
        }
      }
      
      // Align obstacle spawn with ground dashes
      const dashWidth = 12;
      const dashSpacing = 12;
      const patternLength = dashWidth + dashSpacing;
      const offsetAlign = groundOffset % patternLength;
      const spawnX = gameContainer.offsetWidth + offsetAlign;
      
      obstacle.style.left = spawnX + 'px';
      
      // Position obstacles based on type
      if (randomObstacleIndex === -1) {
        // GIF obstacles - lifted by 3 more pixels from previous position
        obstacle.style.bottom = (groundY - 6) + 'px';
      } else if (randomObstacleIndex === 0) {
        // Obstacle 1 (16.png) - lifted by 3 pixels (was groundY - 10, now groundY - 7)
        obstacle.style.bottom = (groundY - 7) + 'px';
      } else if (randomObstacleIndex === 1) {
        // Obstacle 2 (15.png) - leave intact
        obstacle.style.bottom = (groundY - 3) + 'px';
      } else if (randomObstacleIndex === 2) {
        // Obstacle 3 (Pixelion-7.png) - much more forgiving hitbox (90% X, 90% Y margins) + upper 50% removed
        obstacle.style.bottom = groundY + 'px';
        obstacle.style.transform = 'translateY(' + (height * 0.3) + 'px)';
      } else if (randomObstacleIndex === 3) {
        // Obstacle 4 (17.png) - lifted by 3 pixels (was groundY - 10, now groundY - 7)
        obstacle.style.bottom = (groundY - 7) + 'px';
      } else {
        // Fallback for any other obstacles - position on ground
        obstacle.style.bottom = groundY + 'px';
      }
      
      obstacle.style.height = height + 'px';
      obstacle.style.width = width + 'px';
      obstacle.style.objectFit = 'contain'; // Prevent distortion
      obstacle.style.imageRendering = 'pixelated';
      
      // Add error handling for image loading
      obstacle.onerror = function() {
        console.warn('Failed to load obstacle image:', this.src);
        // Remove the obstacle from DOM if it fails to load
        if (this.parentNode) {
          this.parentNode.removeChild(this);
        }
      };
      
      gameContainer.appendChild(obstacle);
      obstacles.push({ el: obstacle, x: spawnX, width, height, obstacleIndex: randomObstacleIndex });
    }

    function checkCollision(obs) {
      if (!obs || !obs.el) return false;
      
      const playerRect = {
        x: 60,
        y: playerY,
        width: playerSize,
        height: playerSize
      };
      
      let obsRect = {
        x: obs.x,
        y: groundY,
        width: obs.width,
        height: obs.height
      };
      
      // Standardized forgiving hitboxes for consistent gameplay
      let marginX, marginY;
      
      if (obs.el.classList.contains('gif') &&
          (obs.el.src.includes('s2vTvGb0/Pixelion-600-x-1000.gif') || obs.el.src.includes('pdFKwfwx/Pixelion-600-x-1000-1.gif'))) {
        // GIF obstacles - very small hitbox for easy jumping (85% margins)
        marginX = obsRect.width * 0.85;  // Increased from 0.75 to 0.85 (much smaller width hitbox)
        marginY = obsRect.height * 0.85; // Increased from 0.8 to 0.85 (much smaller height hitbox)
        // Remove upper 40% of hitbox to make jumping much easier
        obsRect.y -= obsRect.height * 0.4;
        obsRect.height *= 0.6;
      } else if (typeof obs.obstacleIndex === 'number' && obs.obstacleIndex === 1) {
        // Obstacle 2 (15.png) - extra forgiving horizontal hitbox (75% X, 60% Y)
        marginX = obsRect.width * 0.75;
        marginY = obsRect.height * 0.6;
      } else if (typeof obs.obstacleIndex === 'number' && obs.obstacleIndex === 2) {
        // Obstacle 3 (Pixelion-7.png) - much more forgiving hitbox (90% X, 90% Y margins) + upper 50% removed
        marginX = obsRect.width * 0.9;  // Increased from 0.8 to 0.9 for much smaller hitbox
        marginY = obsRect.height * 0.9; // Increased from 0.7 to 0.9 for much smaller hitbox
        // Remove upper 50% of hitbox (increased from 20% to 50%)
        obsRect.y -= obsRect.height * 0.5;
        obsRect.height *= 0.5;
      } else {
        // All other obstacles - standard forgiving hitbox (60% margins)
        marginX = obsRect.width * 0.6;
        marginY = obsRect.height * 0.6;
      }
      
      obsRect.x += marginX;
      obsRect.y += marginY;
      obsRect.width = Math.max(0, obsRect.width - 2 * marginX);
      obsRect.height = Math.max(0, obsRect.height - 2 * marginY);
      
      return (
        playerRect.x < obsRect.x + obsRect.width &&
        playerRect.x + playerRect.width > obsRect.x &&
        playerRect.y < obsRect.y + obsRect.height &&
        playerRect.y + playerRect.height > obsRect.y
      );
    }

    function drawStars() {
      if (!starsCtx) return;
      
      starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
      
      // Determine if it's night mode
      const period = 200;
      const nightStart = 300;
      const inNight = (score >= nightStart) && (Math.floor((score - nightStart) / period) % 2 === 0);
      
      // Draw night stars first (behind clouds)
      if (inNight && nightStarsImg.complete) {
        starsCtx.save();
        starsCtx.globalAlpha = 1.0;
        starsCtx.drawImage(nightStarsImg, 0, 0, starsCanvas.width, starsCanvas.height);
        starsCtx.restore();
      }
      
      // Draw sky overlay (clouds) on top of stars
      if (skyOverlayImg.complete) {
        starsCtx.save();
        starsCtx.globalAlpha = 0.8;
        starsCtx.drawImage(skyOverlayImg, 0, 0, starsCanvas.width, starsCanvas.height);
        starsCtx.restore();
      }
    }

    function generateStars(count = 60) {
      // Remove star generation - we now use image overlays
      stars = [];
    }

    // Draw 8-bit style pixel art ground
    function drawGround() {
      if (!groundCtx) return;
      
      // Asphalt
      groundCtx.clearRect(0, 0, groundCanvas.width, groundCanvas.height);
      groundCtx.fillStyle = '#444';
      groundCtx.fillRect(0, 0, groundCanvas.width, groundCanvas.height);
      
      // Dashes (thinner, smaller, more frequent)
      const dashWidth = 12;
      const dashHeight = 3;
      const dashSpacing = 12;
      
      groundCtx.save();
      groundCtx.globalAlpha = 0.8;
      groundCtx.fillStyle = '#e0e0e0';
      
      for (let x = -groundOffset % (dashWidth + dashSpacing); x < groundCanvas.width; x += dashWidth + dashSpacing) {
        groundCtx.fillRect(Math.round(x), 7, dashWidth, dashHeight);
      }
      
      groundCtx.globalAlpha = 1.0;
      groundCtx.restore();
    }

    // Improved error handling
    window.onerror = function(message, source, lineno, colno, error) {
      console.error('Global error:', message, source, lineno, colno, error);
      // Don't show alert in production, just log
      return false;
    };

    function gameLoop(timestamp) {
      try {
        if (!gameRunning) return;
        
        if (!lastTime) lastTime = timestamp;
        const delta = timestamp - lastTime;
        lastTime = timestamp;

        // Gradually increase speed over time
        obstacleSpeed = Math.min(3 + score * 0.001, 7.0);
        if (speedDisplay) {
          speedDisplay.textContent = '–°–∫–æ—Ä–æ—Å—Ç—å: ' + obstacleSpeed.toFixed(1);
        }

        // Alternate night and day every 200 points, starting at 300
        const period = 200;
        const nightStart = 300;
        const inNight = (score >= nightStart) && (Math.floor((score - nightStart) / period) % 2 === 0);

        if (inNight && !darkMode) {
          // Transitioning to night mode
          gameContainer.classList.add('dark');
          nightOverlay.classList.add('active');
          if (h1) h1.style.color = '#ff69b4';
          if (p) p.style.color = '#ff69b4';
          if (scoreDisplay) scoreDisplay.style.color = '#ff69b4';
          if (highScoreDisplay) highScoreDisplay.style.color = '#ff69b4';
          if (gameOverDisplay) gameOverDisplay.style.color = '#ff69b4';
          darkMode = true;
        } else if (!inNight && darkMode) {
          // Transitioning to day mode
          gameContainer.classList.remove('dark');
          nightOverlay.classList.remove('active');
          if (h1) h1.style.color = '#ff69b4';
          if (p) p.style.color = '#ff69b4';
          if (scoreDisplay) scoreDisplay.style.color = '#ff69b4';
          if (highScoreDisplay) highScoreDisplay.style.color = '#ff69b4';
          if (gameOverDisplay) gameOverDisplay.style.color = '#ff69b4';
          if (starsCtx) {
            starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
          }
        }
        
        // Always draw stars (for smooth transitions)
        drawStars();

        // Player physics
        velocityY -= gravity;
        playerY += velocityY;
        
        if (playerY <= groundY - 3) { // Updated to match new starting position
          playerY = groundY - 3;
          velocityY = 0;
          if (isJumping) {
            isJumping = false;
            updatePlayerSprite(); // Switch back to running when landing
          }
        }
        
        if (player) {
          player.style.bottom = playerY + 'px';
        }

        // Obstacles - only spawn if game is running
        if (gameRunning) {
          obstacleTimer += delta;
          const adjustedInterval = nextObstacleInterval * (isSafari ? 1.2 : 1.0); // 20% longer intervals in Safari
          if (obstacleTimer > adjustedInterval) {
            spawnObstacle();
            obstacleTimer = 0;
            nextObstacleInterval = 1320 + Math.random() * 1080; // random between 1320-2400ms (20% less frequent)
          }
        }
        
        // Use transform for better performance in Safari
        obstacles.forEach(obs => {
          obs.x -= obstacleSpeed * (delta / 16.67); // Make frame-rate dependent like ground
          if (obs.el) {
            if (isSafari) {
              // Use transform for better Safari performance
              obs.el.style.transform = `translateX(${obs.x}px)`;
            } else {
              obs.el.style.left = obs.x + 'px';
            }
          }
        });
        
        for (let i = obstacles.length - 1; i >= 0; i--) {
          const obs = obstacles[i];
          if (!obs || !obs.el) {
            obstacles.splice(i, 1);
            continue;
          }
          
          if (checkCollision(obs)) {
            endGame();
            return;
          }
          
          if (obs.x + obs.width < 0) {
            if (obs.el && obs.el.parentNode) {
              obs.el.remove();
            }
            obstacles.splice(i, 1);
          }
        }

        // Spawn scissors (birds) after score 200, with random interval
        if (score >= 200 && gameRunning) {
          scissorsTimer += delta;
          if (scissorsTimer > nextScissorsInterval) {
            spawnScissors();
            scissorsTimer = 0;
          }
        }
        updateScissors(delta);

        // Score
        score += delta * 0.01;
        if (scoreDisplay) {
          scoreDisplay.textContent = '–°—á—ë—Ç: ' + Math.floor(score);
        }
        
        // Update high score if current score is higher
        updateHighScore(score);

        // Move ground offset with the same speed as obstacles (frame-rate dependent)
        groundOffset += obstacleSpeed * (delta / 16.67); // Normalize to 60fps (16.67ms per frame)
        if (groundOffset > 24) groundOffset -= 24; // Match dash pattern length (12+12=24)
        drawGround();

        if (!isGameOver && gameRunning) {
          animationId = requestAnimationFrame(gameLoop);
        }
      } catch (e) {
        console.error('Game loop error:', e);
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
        isGameOver = true;
        gameRunning = false;
        if (gameOverDisplay) {
          gameOverDisplay.style.display = 'block';
        }
      }
    }

    function endGame() {
      if (isGameOver) return; // Prevent multiple calls
      isGameOver = true;
      gameRunning = false;
      
      if (gameOverDisplay) {
        gameOverDisplay.style.display = 'block';
      }
      
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      stopBackgroundMusic();
      
      if (soundsOn && loseSound) {
        try {
          loseSound.currentTime = 0;
          loseSound.play().then(() => {
            loseSound.onended = function() {
              if (soundOn) {
                startBackgroundMusic();
              }
              loseSound.onended = null; // Reset handler
            };
          }).catch(e => {
            console.warn('Could not play lose sound:', e);
            if (soundOn) {
              startBackgroundMusic();
            }
          });
        } catch (e) {
          console.warn('Lose sound error:', e);
          if (soundOn) {
            startBackgroundMusic();
          }
        }
      } else {
        if (soundOn) {
          startBackgroundMusic();
        }
      }
    }

    window.restartGame = function() {
      try {
        localStorage.setItem('musicOn', soundOn ? 'true' : 'false');
      } catch (e) {
        console.warn('Could not save to localStorage:', e);
      }
      location.reload();
    };

    // Asset URLs to preload
    const assetUrls = [
      'https://i.postimg.cc/s2vTvGb0/Pixelion-600-x-1000.gif',
      'https://i.postimg.cc/pdFKwfwx/Pixelion-600-x-1000-1.gif',
      'https://i.postimg.cc/NM6G70K8/ezgif-com-animated-gif-maker.gif',
      'https://i.postimg.cc/dtBqYwh3/Pixelion.png',
      'https://i.postimg.cc/DyDdLcHT/ezgif-com-optimize.gif',
      'https://i.postimg.cc/GpBrGDqT/Pixelion-2.png',
      'https://i.postimg.cc/Fzz3Jfxz/13-1.png',
      'https://i.postimg.cc/pThkg1gq/18.png',
      'https://i.postimg.cc/vHNFnpGZ/16.png',
      'https://i.postimg.cc/8CLqqcM7/15.png',
      'https://i.postimg.cc/85DqDGmt/Pixelion-7.png',
      'https://i.postimg.cc/FzwprgQN/17.png'
    ];
    
    const audioUrls = [
      'https://dl.dropboxusercontent.com/scl/fi/u8vy9c7rk8uh86l4iy2ef/Swan-Lake-Theme.mp3?rlkey=c9gl4gd9i4jy5f25esiqd1ra3&st=jla22prl',
      'https://dl.dropboxusercontent.com/scl/fi/03ewjm0np47rvxwvkw4fr/080047_lose_funny_retro_video-game-80925.mp3?rlkey=f5sz95h1alf549ppriqkv7ees&st=8t37iozp',
      'https://dl.dropboxusercontent.com/scl/fi/ezrm6z3cx6zia9ski74nd/retro-jump-1-236684.mp3?rlkey=cbxvo5jhokcw9f68d4plxeuuf&st=b95r8mro',
    ];

    function preloadAssets(callback) {
      let loaded = 0;
      const total = assetUrls.length + audioUrls.length;
      
      function check() {
        loaded++;
        if (loaded === total) {
          callback();
        }
      }
      
      assetUrls.forEach(url => {
        const img = new Image();
        img.onload = check;
        img.onerror = () => {
          console.warn('Failed to load image:', url);
          check();
        };
        img.src = url;
      });
      
      audioUrls.forEach(url => {
        const audio = new Audio();
        audio.oncanplaythrough = check;
        audio.onerror = () => {
          console.warn('Failed to load audio:', url);
          check();
        };
        audio.src = url;
      });
    }

    // Hide game UI until loaded
    const loadingDiv = document.getElementById('loading');
    const gameContainerDiv = document.getElementById('gameContainer');
    
    if (gameContainerDiv) {
      gameContainerDiv.style.display = 'none';
    }

    // Initialize the game
    preloadAssets(() => {
      if (loadingDiv) {
        loadingDiv.style.display = 'none';
      }
      if (gameContainerDiv) {
        gameContainerDiv.style.display = '';
      }
      
      initializeAudio();
      resetGame();
    });

    // Improved audio initialization with error handling
    function initializeAudio() {
      try {
        // Don't auto-play on load - wait for user interaction
        gameMusic.volume = 0.7;
        loseSound.volume = 0.8;
        jumpSound.volume = 0.6;
      } catch (e) {
        console.warn('Audio initialization error:', e);
      }
    }
  </script>
</body>
</html>