<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=720, initial-scale=1.0">
  <title>–ü–†–ò–ö–õ–Æ–ß–ï–ù–ò–Ø –°–û–§–ò–ò</title>
  
  <!-- Preconnect to external image hosts for faster loading -->
  <link rel="preconnect" href="https://i.postimg.cc" crossorigin>
  <link rel="preconnect" href="https://dl.dropboxusercontent.com" crossorigin>
  <link rel="dns-prefetch" href="https://i.postimg.cc">
  <link rel="dns-prefetch" href="https://dl.dropboxusercontent.com">
  
  <!-- Preload critical player sprites -->
  <link rel="preload" as="image" href="https://i.postimg.cc/dtBqYwh3/Pixelion.png" crossorigin>
  <link rel="preload" as="image" href="https://i.postimg.cc/DyDdLcHT/ezgif-com-optimize.gif" crossorigin>
  <link rel="preload" as="image" href="https://i.postimg.cc/GpBrGDqT/Pixelion-2.png" crossorigin>
  
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body {
      background: #fff; /* page background is white */
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: 'Press Start 2P', cursive;
      margin: 0;
      padding: 0;
    }
    #gameContainer {
      position: relative;
      width: 720px;
      height: 240px;
      background: linear-gradient(to bottom, #2196f3 0%, #b3e5fc 100%); /* blue sky gradient */
      border: 2px solid #333;
      overflow: hidden;
      margin-top: 40px;
      box-shadow: 0 4px 24px 0 rgba(63,69,81,0.16);
      /* Safari performance optimizations */
      -webkit-transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      -webkit-perspective: 1000;
    }
    #gameContainer.dark {
      background: #222;
    }
    #gameContainer.night {
      background: linear-gradient(to bottom, #070b1f 0%, #0a0f2e 15%, #0d1847 35%, #2d1b69 65%, #4a1a6b 85%, #6b2c5c 100%);
    }
    #nightOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, #070b1f 0%, #0a0f2e 15%, #0d1847 35%, #2d1b69 65%, #4a1a6b 85%, #6b2c5c 100%);
      opacity: 0;
      transition: opacity 3s ease-in-out;
      pointer-events: none;
      z-index: 0;
    }
    #nightOverlay.active {
      opacity: 1;
    }
    #player {
      position: absolute;
      left: 60px;
      bottom: 21px; /* Moved down 3 pixels from 24px to 21px */
      width: 72px;
      height: 72px;
      object-fit: contain;
      image-rendering: pixelated;
      user-select: none;
      pointer-events: none;
      z-index: 5; /* Above obstacles, below scissors */
      /* Safari performance optimizations */
      -webkit-transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      will-change: transform;
    }
    .obstacle {
      position: absolute;
      bottom: 24px;
      width: 24px;
      height: 48px;
      z-index: 4; /* Above road, below main character */
      /* Safari performance optimizations */
      -webkit-transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      will-change: transform;
    }
    .obstacle.gif {
      width: 36px !important;
      height: 72px !important;
      bottom: 24px;
    }
    .obstacle:not(img) {
      background: #e53935;
      border-radius: 4px;
    }
    #ground {
      position: absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 24px;
      background: #bbb; /* lighter grey road */
      transition: background 3s ease-in-out; /* Match day/night transition duration */
    }
    #gameContainer.dark #ground {
      background: #666;
    }
    #score, #gameOver, h1, p, #highScore {
      color: #ff69b4 !important; /* bright pink */
      transition: color 3s ease-in-out; /* Match day/night transition duration */
    }
    #streakCounter {
      position: absolute;
      top: 10px;
      right: 10px;
      color: #ff69b4;
      font-family: 'Press Start 2P', cursive;
      font-size: 0.8em;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 12px;
      border: 2px solid #ff69b4;
      border-radius: 6px;
      transition: all 0.3s ease;
      z-index: 15;
      display: none;
    }
    #streakCounter.show {
      display: block;
      animation: streakPulse 0.5s ease-out;
    }
    #gameContainer.dark #streakCounter {
      background: rgba(34, 34, 34, 0.9);
      color: #ff69b4;
      border-color: #ff69b4;
    }
    @keyframes streakPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .flying-score {
      position: absolute;
      font-family: 'Press Start 2P', cursive;
      font-size: 1em;
      color: #4CAF50;
      font-weight: bold;
      text-shadow: 2px 2px 0px rgba(0,0,0,0.5);
      pointer-events: none;
      z-index: 12;
      animation: flyUp 1.5s ease-out forwards;
    }
    @keyframes flyUp {
      0% {
        opacity: 1;
        transform: translateY(0px) scale(1);
      }
      20% {
        opacity: 1;
        transform: translateY(-20px) scale(1.2);
      }
      100% {
        opacity: 0;
        transform: translateY(-80px) scale(0.8);
      }
    }
    #gameOver {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.95);
      padding: 24px 40px;
      border: 2px solid #ff69b4; /* bright pink border */
      border-radius: 8px;
      font-size: 1.5em;
      z-index: 20;
      text-align: center;
    }
    #gameContainer.dark #gameOver {
      background: rgba(34,34,34,0.95);
      border-color: #ff69b4;
    }
    button {
      margin-top: 16px;
      padding: 8px 20px;
      font-size: 1em;
      border-radius: 6px;
      border: 1px solid #333;
      background: #fff;
      cursor: pointer;
    }
    button:hover {
      background: #eee;
    }
    .obstacle.special {
      width: 48px !important;
      height: 48px !important;
      object-fit: contain;
      image-rendering: pixelated;
      bottom: 24px !important;
    }
    .scissors-bird {
      pointer-events: none;
      user-select: none;
      image-rendering: pixelated;
      transition: filter 0.3s;
      z-index: 6; /* Top layer - above main character */
    }
    .styled-btn {
      font-family: 'Press Start 2P', cursive;
      font-size: 1em;
      color: #2196f3;
      background: #fff;
      border: 2px solid #2196f3;
      border-radius: 8px;
      padding: 8px 18px;
      margin: 0;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
      outline: none;
      box-shadow: 0 2px 8px 0 rgba(33,150,243,0.08);
      letter-spacing: 1px;
    }
    .styled-btn:hover, .styled-btn:focus {
      background: #e3f2fd;
      color: #1565c0;
    }
    .obstacle.png5 { image-rendering: pixelated; object-fit: contain; }
    .obstacle.png6 { image-rendering: pixelated; object-fit: contain; }
    
    /* Glowing Effects */
    .scissors-bird {
      pointer-events: none;
      user-select: none;
      image-rendering: pixelated;
      transition: filter 0.3s;
      z-index: 6;
      filter: drop-shadow(0 0 8px rgba(255,69,0,0.7)) drop-shadow(0 0 16px rgba(255,69,0,0.4));
      animation: ominousGlow 2s ease-in-out infinite alternate;
    }
    
    @keyframes ominousGlow {
      0% {
        filter: drop-shadow(0 0 8px rgba(255,69,0,0.7)) drop-shadow(0 0 16px rgba(255,69,0,0.4));
      }
      100% {
        filter: drop-shadow(0 0 12px rgba(255,69,0,0.9)) drop-shadow(0 0 24px rgba(255,69,0,0.6));
      }
    }
  </style>
</head>
<body>
  <h1>–ü–†–ò–ö–õ–Æ–ß–ï–ù–ò–Ø –°–û–§–ò–ò</h1>
  <div id="highScore" style="color:#ff69b4;margin-bottom:8px;">–õ—É—á—à–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: 0</div>
  <div id="score">–°—á—ë—Ç: 0</div>
  <div id="speed" style="color:#2196f3;margin-bottom:20px;margin-top:8px;">–°–∫–æ—Ä–æ—Å—Ç—å: 0.0</div>
  <div id="loading" style="font-family:'Press Start 2P',cursive;font-size:1.2em;color:#2196f3;margin-top:40px;">
    <div style="margin-bottom:16px;">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
    <div id="loadingProgress" style="width:300px;height:20px;border:2px solid #2196f3;border-radius:10px;margin:0 auto;background:#fff;position:relative;overflow:hidden;">
      <div id="loadingBar" style="height:100%;background:linear-gradient(90deg, #2196f3, #64b5f6);width:0%;transition:width 0.3s ease;border-radius:8px;"></div>
      <div id="loadingText" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:10px;color:#333;font-weight:bold;">0%</div>
    </div>
    <div id="loadingStatus" style="font-size:0.8em;margin-top:12px;color:#666;">–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ –∏–≥—Ä–µ...</div>
  </div>
  <div id="gameContainer">
    <div id="nightOverlay"></div>
    <div id="streakCounter">Streak: 0</div>
    <canvas id="stars" width="720" height="240" style="position:absolute;left:0;top:0;pointer-events:none;z-index:1;"></canvas>
    <canvas id="clouds" width="720" height="240" style="position:absolute;left:0;top:0;pointer-events:none;z-index:2;"></canvas>
    <img id="player" src="https://i.postimg.cc/dtBqYwh3/Pixelion.png" alt="–ò–≥—Ä–æ–∫" style="z-index:5;position:absolute;" />
    <canvas id="groundCanvas" width="720" height="24" style="z-index:3;position:absolute;left:0;bottom:0;"></canvas>
    <div id="gameOver" style="z-index:20;position:absolute;">
      –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!<br>
      <button onclick="restartGame()">–ó–∞–Ω–æ–≤–æ</button>
    </div>
  </div>
  <div style="margin-top:16px; display:flex; gap:12px; align-items:center;">
    <button id="soundsToggle" class="styled-btn">üîä –ó–≤—É–∫–∏: –í–∫–ª</button>
    <button id="soundToggle" class="styled-btn">üéµ –ú—É–∑—ã–∫–∞: –í—ã–∫–ª</button>
  </div>
  <audio id="loseSound" src="https://dl.dropboxusercontent.com/scl/fi/03ewjm0np47rvxwvkw4fr/080047_lose_funny_retro_video-game-80925.mp3?rlkey=f5sz95h1alf549ppriqkv7ees&st=8t37iozp" preload="auto"></audio>
  <audio id="gameMusic" src="https://dl.dropboxusercontent.com/scl/fi/u8vy9c7rk8uh86l4iy2ef/Swan-Lake-Theme.mp3?rlkey=c9gl4gd9i4jy5f25esiqd1ra3&st=jla22prl" loop preload="auto"></audio>
  <audio id="jumpSound" src="https://dl.dropboxusercontent.com/scl/fi/ezrm6z3cx6zia9ski74nd/retro-jump-1-236684.mp3?rlkey=cbxvo5jhokcw9f68d4plxeuuf&st=b95r8mro" preload="auto"></audio>
  <p>–ù–∞–∂–º–∏—Ç–µ <b>–ü—Ä–æ–±–µ–ª</b> –∏–ª–∏ <b>–°—Ç—Ä–µ–ª–∫—É –≤–≤–µ—Ä—Ö</b>, —á—Ç–æ–±—ã –ø—Ä—ã–≥–Ω—É—Ç—å.</p>
  <script>
    const gameContainer = document.getElementById('gameContainer');
    const player = document.getElementById('player');
    const scoreDisplay = document.getElementById('score');
    const highScoreDisplay = document.getElementById('highScore');
    const gameOverDisplay = document.getElementById('gameOver');
    const groundCanvas = document.getElementById('groundCanvas');
    const groundCtx = groundCanvas.getContext('2d');
    let groundOffset = 0;
    const h1 = document.querySelector('h1');
    const p = document.querySelector('p');
    const starsCanvas = document.getElementById('stars');
    const starsCtx = starsCanvas.getContext('2d');
    const cloudsCanvas = document.getElementById('clouds');
    const cloudsCtx = cloudsCanvas.getContext('2d');
    let stars = [];
    const nightOverlay = document.getElementById('nightOverlay');
    const streakCounter = document.getElementById('streakCounter');
    
    // Game settings
    const gravity = 0.5; // Reduced from 0.8 for frame-rate dependent physics
    const jumpStrength = 12; // Reduced from 15 for frame-rate dependent physics
    let obstacleSpeed = 3; // starting speed changed to 3
    let nextObstacleInterval = 1320 + Math.random() * 1080; // random between 1320-2400ms (20% less frequent)
    const groundY = 24;
    const playerSize = 72;
    let playerY = groundY - 11; // Lowered by 5 pixels from the original groundY - 6
    let velocityY = 0;
    let isJumping = false;
    let isGameOver = false;
    let score = 0;
    let obstacles = [];
    let obstacleTimer = 0;
    let lastTime = null;
    let animationId = null;
    let gifObstaclesCount = 0;
    let darkMode = false;
    let flickerInterval = null;
    let landingGracePeriod = 0; // Grace period after landing to prevent unfair collisions
    
    // Streak and scoring system
    let currentStreak = 0;
    let flyingScoreElements = [];
    let lastObstacleCleared = null;
    
    // Visual effects variables
    let sparkleParticles = [];
    let fallingStars = [];
    let shadowElements = [];
    let sparkleTimer = 0;
    let godRays = null;
    let moonbeams = null;

    // Safari performance optimizations
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    const performanceMultiplier = isSafari ? 0.9 : 1.0; // Slightly reduce spawn rate for Safari

    // Character images
    const playerStandingImg = "https://i.postimg.cc/dtBqYwh3/Pixelion.png";
    const playerRunningImg = "https://i.postimg.cc/DyDdLcHT/ezgif-com-optimize.gif";
    const playerJumpingImg = "https://i.postimg.cc/GpBrGDqT/Pixelion-2.png";

    // Sky overlay image for day and night
    const skyOverlayImg = new Image();
    skyOverlayImg.src = 'https://i.postimg.cc/Fzz3Jfxz/13-1.png';

    // Night stars overlay image
    const nightStarsImg = new Image();
    nightStarsImg.src = 'https://i.postimg.cc/pThkg1gq/18.png';

    // New obstacle images
    const obstacleImages = [
      'https://i.postimg.cc/vHNFnpGZ/16.png',
      'https://i.postimg.cc/8CLqqcM7/15.png',
      'https://i.postimg.cc/85DqDGmt/Pixelion-7.png',
      'https://i.postimg.cc/FzwprgQN/17.png'
    ];

    // --- FLYING SCISSORS (BIRDS) ---
    let scissors = [];
    const scissorsImg = 'https://i.postimg.cc/NM6G70K8/ezgif-com-animated-gif-maker.gif';
    let scissorsTimer = 0;
    let scissorsStartScore = null;
    let nextScissorsInterval = 5000 + Math.random() * 5000; // 5-10 seconds at first

    // Function to create flying score popup
    function createFlyingScore(points, x, y) {
      const flyingScore = document.createElement('div');
      flyingScore.className = 'flying-score';
      flyingScore.textContent = '+' + points;
      flyingScore.style.left = x + 'px';
      flyingScore.style.top = y + 'px';
      
      gameContainer.appendChild(flyingScore);
      flyingScoreElements.push(flyingScore);
      
      // Remove after animation completes
      setTimeout(() => {
        if (flyingScore.parentNode) {
          flyingScore.parentNode.removeChild(flyingScore);
        }
        const index = flyingScoreElements.indexOf(flyingScore);
        if (index > -1) {
          flyingScoreElements.splice(index, 1);
        }
      }, 1500);
    }

    // Function to update streak counter
    function updateStreakCounter() {
      if (currentStreak > 0) {
        streakCounter.textContent = 'Streak: ' + currentStreak;
        streakCounter.classList.add('show');
        // Trigger pulse animation
        streakCounter.classList.remove('show');
        setTimeout(() => streakCounter.classList.add('show'), 10);
      } else {
        streakCounter.classList.remove('show');
      }
    }

    // Function to handle obstacle clearance
    function handleObstacleClear(obstacle) {
      currentStreak++;
      updateStreakCounter();
      
      // Create flying score popup at obstacle position
      const points = 10 + (currentStreak > 5 ? Math.min(currentStreak - 5, 10) : 0); // Bonus points for streak
      createFlyingScore(points, obstacle.x, groundY - 40);
      
      // Don't add to main score - keep it separate for better game balance
      // The main score is based on time survived (score += cappedDelta * 0.01)
    }

    // Function to reset streak
    function resetStreak() {
      currentStreak = 0;
      updateStreakCounter();
    }

    // Helper to check if a new scissors would create a safe path for the player
    function isScissorsSafe(x, width) {
      const playerJumpRange = 200; // Increased to match obstacle safety
      const playerMaxJumpHeight = 120; // Maximum jump height
      const safetyMargin = 300; // Increased from 250 to 300 to match obstacle safety
      
      for (const obs of obstacles) {
        // Only check obstacles that are still on screen or will be soon
        if (obs.x + obs.width < -100) continue;
        
        // Check if scissors would overlap horizontally with an obstacle (with margin)
        if (x < obs.x + obs.width + safetyMargin && x + width > obs.x - safetyMargin) {
          return false;
        }
        
        // Advanced check: ensure player can safely jump over obstacle without hitting scissors
        // Calculate where player would be when encountering this obstacle-scissors combo
        const obstaclePlayerMeetX = obs.x - 60; // When player reaches obstacle
        const scissorsPlayerMeetX = x - 60; // When player reaches scissors
        
        // If both are close, check if there's a safe jumping path
        if (Math.abs(obstaclePlayerMeetX - scissorsPlayerMeetX) < playerJumpRange) {
          // ALWAYS reject low scissors near ground obstacles (removed randomness)
          return false; // Don't spawn scissors near obstacles - period!
        }
      }
      
      // Check against other scissors to prevent clustering
      for (const sc of scissors) {
        if (sc.x + sc.width < -100) continue;
        if (x < sc.x + sc.width + 200 && x + width > sc.x - 200) {
          return false;
        }
      }
      
      return true;
    }

    // Helper to check if a new obstacle would create a safe path with nearby scissors
    function isObstacleSafe(x, width) {
      const playerJumpRange = 200; // Increased from 150 to 200 for more safety
      const safetyMargin = 300; // Increased from 200 to 300 for more spacing
      
      for (const sc of scissors) {
        // Only check scissors that are still on screen or will be soon
        if (sc.x + sc.width < -100) continue;
        
        // Calculate interaction zone
        const obstaclePlayerMeetX = x - 60; // When player reaches obstacle
        const scissorsPlayerMeetX = sc.x - 60; // When player reaches scissors
        
        // If obstacle and scissors are close, ALWAYS reject (no exceptions)
        if (Math.abs(obstaclePlayerMeetX - scissorsPlayerMeetX) < playerJumpRange) {
          return false; // No obstacles near scissors - period!
        }
        
        // Prevent obstacles too close to scissors horizontally (increased margin)
        if (x < sc.x + sc.width + safetyMargin && x + width > sc.x - safetyMargin) {
          return false;
        }
      }
      
      return true;
    }

    function spawnScissors() {
      // Only spawn if score >= 200
      if (score < 200) return;
      if (scissorsStartScore === null) scissorsStartScore = score;
      const width = Math.round(54 * 1.3); // 30% bigger
      const height = Math.round(36 * 1.3); // 30% bigger
      let x = gameContainer.offsetWidth;
      // Try up to 5 times to find a safe spawn position
      let safe = false;
      for (let tries = 0; tries < 5; tries++) {
        if (isScissorsSafe(x, width)) {
          safe = true;
          break;
        }
        x += 40; // move further right if not safe
      }
      if (!safe) return; // skip spawning if can't find a safe spot
      
      // Additional safety: if we have too many obstacles on screen, skip scissors entirely
      if (obstacles.length > 2) return;
      const sc = document.createElement('img');
      sc.src = scissorsImg;
      sc.className = 'scissors-bird';
      sc.style.position = 'absolute';
      sc.style.width = width + 'px';
      sc.style.height = height + 'px';
      sc.style.left = x + 'px';
      
      // Smart altitude selection based on nearby obstacles
      let altitude;
      let hasNearbyGroundObstacles = false;
      
      // Check for ground obstacles within jumping range
      for (const obs of obstacles) {
        if (obs.x + obs.width < 0) continue;
        const distanceToObstacle = Math.abs(obs.x - x);
        if (distanceToObstacle < 300) { // Within interaction range
          hasNearbyGroundObstacles = true;
          break;
        }
      }
      
      if (hasNearbyGroundObstacles) {
        // If there are ground obstacles nearby, strongly prefer high altitude
        if (Math.random() < 0.95) { // 95% chance for high when obstacles nearby
          altitude = 160 + Math.random() * 20; // high: 160-180 px from bottom
        } else {
          altitude = 60 + Math.random() * 20; // low: 60-80 px from bottom
        }
      } else {
        // No nearby obstacles, normal distribution
        if (Math.random() < 0.8) {
          altitude = 160 + Math.random() * 20; // high: 160-180 px from bottom
        } else {
          altitude = 60 + Math.random() * 20; // low: 60-80 px from bottom
        }
      }
      
      sc.style.bottom = altitude + 'px';
      sc.style.zIndex = 6; // Top layer - above main character
      gameContainer.appendChild(sc);
      scissors.push({ el: sc, x: x, y: altitude, width, height, cleared: false });
      // Set next spawn interval with increasing frequency after score 700
      if (scissorsStartScore !== null && score - scissorsStartScore < 100) {
        // Early: 5-10 seconds (reduced from 9-15)
        nextScissorsInterval = 5000 + Math.random() * 5000;
      } else if (score >= 700) {
        // After score 700: gradually increase frequency (shorter intervals)
        const progressAfter700 = Math.min((score - 700) / 300, 1); // 0 to 1 over next 300 points
        const minInterval = 3000; // Minimum 3 seconds
        const maxInterval = 8000; // Maximum 8 seconds
        const baseInterval = maxInterval - (progressAfter700 * (maxInterval - minInterval));
        nextScissorsInterval = baseInterval + Math.random() * 2000; // Add some randomness
      } else {
        // Normal frequency: 5-10 seconds
        nextScissorsInterval = 5000 + Math.random() * 5000;
      }
    }

    function updateScissors(delta) {
      scissors.forEach(sc => {
        sc.x -= (obstacleSpeed + 1.5) * (delta / 16.67); // Make frame-rate dependent
        if (isSafari) {
          // Use transform for better Safari performance
          sc.el.style.transform = `translateX(${sc.x}px)`;
        } else {
          sc.el.style.left = sc.x + 'px';
        }
      });
      for (let i = scissors.length - 1; i >= 0; i--) {
        const sc = scissors[i];
        if (checkScissorsCollision(sc)) {
          resetStreak(); // Reset streak on collision
          endGame();
          return;
        }
        
        // Check if scissors was cleared (passed the player)
        if (sc.x + sc.width < 60 && !sc.cleared) { // Player is at x=60
          sc.cleared = true; // Mark as cleared to avoid multiple triggers
          handleObstacleClear(sc); // Same scoring as obstacles
        }
        
        if (sc.x + sc.width < 0) {
          sc.el.remove();
          scissors.splice(i, 1);
        }
      }
    }

    function checkScissorsCollision(sc) {
      // Landing grace period - don't check collisions for 50ms after landing
      if (landingGracePeriod > 0) return false;
      
      const playerRect = {
        x: 60,
        y: playerY,
        width: playerSize,
        height: playerSize
      };
      
      // Safety check: only check collision if scissors are close to player horizontally
      const horizontalDistance = Math.abs(sc.x - playerRect.x);
      
      // Extra safety buffer for Safari transform rendering delays
      const safetDistance = isSafari ? 110 : 100; // Extra 10px buffer for Safari
      
      if (horizontalDistance > safetDistance) { // Only check when very close
        return false;
      }
      
      // Shrink the scissors hitbox to 35% (65% margin on all sides for more forgiveness)
      const marginX = sc.width * 0.65;
      const marginY = sc.height * 0.65;
      
      // Convert scissors bottom-based position to match player coordinate system
      // sc.y is the altitude (distance from bottom), so we need to convert it
      const scissorsY = sc.y; // This is already the correct Y position (distance from bottom)
      
      const scRect = {
        x: sc.x + marginX,
        y: scissorsY + marginY,
        width: sc.width - 2 * marginX,
        height: sc.height - 2 * marginY
      };
      return (
        playerRect.x < scRect.x + scRect.width &&
        playerRect.x + playerRect.width > scRect.x &&
        playerRect.y < scRect.y + scRect.height &&
        playerRect.y + playerRect.height > scRect.y
      );
    }

    const speedDisplay = document.getElementById('speed');
    const soundToggleBtn = document.getElementById('soundToggle');
    const soundsToggleBtn = document.getElementById('soundsToggle');
    const gameMusic = document.getElementById('gameMusic');
    const loseSound = document.getElementById('loseSound');
    const jumpSound = document.getElementById('jumpSound');
    let soundOn = false;
    let soundsOn = true;
    let highScore = 0;
    
    // Load music state and high score from localStorage with proper error handling
    try {
      const savedSoundOn = localStorage.getItem('musicOn');
      if (savedSoundOn !== null) {
        soundOn = savedSoundOn === 'true';
      }
      const savedHighScore = localStorage.getItem('highScore');
      if (savedHighScore !== null) {
        highScore = parseInt(savedHighScore) || 0;
      }
    } catch (e) {
      console.warn('Could not access localStorage:', e);
    }
    
    // Ensure sounds follow music state on initialization
    if (!soundOn) {
      soundsOn = false;
    }
    
    updateMusicButton();
    updateSoundsButton();
    updateHighScoreDisplay();
    
    function updateMusicButton() {
      if (soundToggleBtn) {
        soundToggleBtn.textContent = soundOn ? 'üéµ –ú—É–∑—ã–∫–∞: –í–∫–ª' : 'üéµ –ú—É–∑—ã–∫–∞: –í—ã–∫–ª';
      }
    }
    
    function updateSoundsButton() {
      if (soundsToggleBtn) {
        soundsToggleBtn.textContent = soundsOn ? 'üîä –ó–≤—É–∫–∏: –í–∫–ª' : 'üîä –ó–≤—É–∫–∏: –í—ã–∫–ª';
      }
    }

    function updateHighScoreDisplay() {
      if (highScoreDisplay) {
        highScoreDisplay.textContent = '–õ—É—á—à–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: ' + Math.floor(highScore);
      }
    }

    function updateHighScore(currentScore) {
      if (currentScore > highScore) {
        highScore = currentScore;
        updateHighScoreDisplay();
        try {
          localStorage.setItem('highScore', highScore.toString());
        } catch (e) {
          console.warn('Could not save high score to localStorage:', e);
        }
      }
    }

    function startBackgroundMusic() {
      if (soundOn && gameMusic) {
        gameMusic.currentTime = 0;
        gameMusic.play().catch(e => {
          console.warn('Could not play background music:', e);
        });
      }
    }

    function stopBackgroundMusic() {
      if (gameMusic) {
        gameMusic.pause();
      }
    }

    if (soundToggleBtn) {
      soundToggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        soundOn = !soundOn;
        
        // When music is turned off, also turn off sounds
        if (!soundOn) {
          soundsOn = false;
          updateSoundsButton();
        }
        
        updateMusicButton();
        try {
          localStorage.setItem('musicOn', soundOn ? 'true' : 'false');
        } catch (e) {
          console.warn('Could not save to localStorage:', e);
        }
        
        if (gameRunning) {
          if (soundOn) {
            startBackgroundMusic();
          } else {
            stopBackgroundMusic();
          }
        }
      });
    }

    if (soundsToggleBtn) {
      soundsToggleBtn.addEventListener('click', function(e) {
        e.preventDefault();
        
        // Only allow sounds to be turned on if music is also on
        if (!soundsOn && !soundOn) {
          // Can't turn sounds on when music is off - do nothing
          return;
        }
        
        soundsOn = !soundsOn;
        updateSoundsButton();
      });
    }

    let gameStarted = false;
    let gameRunning = false;

    function resetGame() {
      generateStars();
      playerY = groundY - 11; // Lowered by 5 pixels from the original groundY - 6
      velocityY = 0;
      isJumping = false;
      isGameOver = false;
      gameStarted = false;
      gameRunning = false;
      score = 0;
      obstacleSpeed = 3;
      if (speedDisplay) {
        speedDisplay.textContent = '–°–∫–æ—Ä–æ—Å—Ç—å: ' + obstacleSpeed.toFixed(1);
      }
      
      // Clean up obstacles
      obstacles.forEach(obs => {
        if (obs.el && obs.el.parentNode) {
          obs.el.remove();
        }
      });
      obstacles = [];
      
      // Clean up scissors
      scissors.forEach(sc => {
        if (sc.el && sc.el.parentNode) {
          sc.el.remove();
        }
      });
      scissors = [];
      scissorsTimer = 0;
      scissorsStartScore = null;
      nextScissorsInterval = 5000 + Math.random() * 5000;
      
      obstacleTimer = 0;
      nextObstacleInterval = 1320 + Math.random() * 1080; // random between 1320-2400ms (20% less frequent)
      lastTime = null;
      gifObstaclesCount = 0;
      darkMode = false;
      
      // Stop flicker effect if running
      if (flickerInterval) {
        clearInterval(flickerInterval);
        flickerInterval = null;
      }
      
      // Reset landing grace period
      landingGracePeriod = 0;
      
      // Reset streak and clean up flying scores
      currentStreak = 0;
      updateStreakCounter();
      flyingScoreElements.forEach(element => {
        if (element.parentNode) {
          element.parentNode.removeChild(element);
        }
      });
      flyingScoreElements = [];
      
      // Clean up visual effects
      sparkleParticles.forEach(sparkle => {
        if (sparkle.parentNode) {
          sparkle.parentNode.removeChild(sparkle);
        }
      });
      sparkleParticles = [];
      
      fallingStars.forEach(star => {
        if (star.parentNode) {
          star.parentNode.removeChild(star);
        }
      });
      fallingStars = [];
      
      shadowElements.forEach(shadow => {
        if (shadow.parentNode) {
          shadow.parentNode.removeChild(shadow);
        }
      });
      shadowElements = [];
      
      sparkleTimer = 0;
      
      // Reset lighting effects
      if (godRays) {
        godRays.classList.remove('active');
      }
      if (moonbeams) {
        moonbeams.classList.remove('active');
      }
      
      if (gameOverDisplay) {
        gameOverDisplay.style.display = 'none';
      }
      
      if (player) {
        player.style.bottom = playerY + 'px';
        player.src = playerStandingImg; // Start with standing image
        player.style.opacity = '1'; // Reset opacity to normal
        player.style.display = 'block'; // Ensure player is visible
        player.style.left = '60px';
        player.style.position = 'absolute';
        player.style.zIndex = '5';
      }
      
      if (scoreDisplay) {
        scoreDisplay.textContent = '–°—á—ë—Ç: 0';
      }
      
      gameContainer.classList.remove('dark');
      if (nightOverlay) {
        nightOverlay.classList.remove('active');
      }
      if (h1) h1.style.color = '#ff69b4';
      if (p) p.style.color = '#ff69b4';
      if (scoreDisplay) scoreDisplay.style.color = '#ff69b4';
      if (highScoreDisplay) highScoreDisplay.style.color = '#ff69b4';
      if (gameOverDisplay) gameOverDisplay.style.color = '#ff69b4';
      
      drawStars();
      groundOffset = 0;
      drawGround();
      
      // Save music state to localStorage
      try {
        localStorage.setItem('musicOn', soundOn ? 'true' : 'false');
      } catch (e) {
        console.warn('Could not save to localStorage:', e);
      }
      
      // Don't start game loop until user presses key
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }

    function startGame() {
      if (!gameStarted) {
        gameStarted = true;
        gameRunning = true;
        if (player) {
          player.src = playerRunningImg; // Switch to running GIF
        }
        if (soundOn) {
          startBackgroundMusic();
        }
        if (!animationId) {
          animationId = requestAnimationFrame(gameLoop);
        }
      }
    }

    function updatePlayerSprite() {
      if (!player) return;
      
      if (!gameRunning) {
        player.src = playerStandingImg;
      } else if (isJumping) {
        player.src = playerJumpingImg;
      } else {
        player.src = playerRunningImg;
      }
    }

    function jump() {
      if (!gameStarted) {
        startGame();
        return;
      }
      
      if (!isJumping && !isGameOver) {
        velocityY = jumpStrength;
        isJumping = true;
        updatePlayerSprite();
        if (soundsOn && jumpSound) {
          try {
            jumpSound.currentTime = 0;
            jumpSound.play().catch(e => {
              console.warn('Could not play jump sound:', e);
            });
          } catch (e) {
            console.warn('Jump sound error:', e);
          }
        }
      }
    }

    // Debug function to log game state
    function debugGameState() {
      console.log('=== GAME DEBUG INFO ===');
      console.log(`Player Y: ${playerY}, Velocity Y: ${velocityY}, isJumping: ${isJumping}`);
      console.log(`Game Running: ${gameRunning}, Game Started: ${gameStarted}`);
      console.log(`Obstacle Speed: ${obstacleSpeed}, Score: ${Math.floor(score)}`);
      console.log(`Active Obstacles: ${obstacles.length}, Active Scissors: ${scissors.length}`);
      console.log(`Landing Grace Period: ${landingGracePeriod}ms`);
      console.log('--- ASSET CACHE STATUS ---');
      console.log(`Cache size: ${assetCache.size}`);
      console.log(`Sky overlay cached: ${assetCache.has('https://i.postimg.cc/Fzz3Jfxz/13-1.png')}`);
      console.log(`Night stars cached: ${assetCache.has('https://i.postimg.cc/pThkg1gq/18.png')}`);
      console.log(`Sky overlay fallback complete: ${skyOverlayImg?.complete}`);
      console.log('========================');
    }

    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        jump();
      } else if (e.code === 'KeyD' && e.ctrlKey) {
        e.preventDefault();
        debugGameState();
      }
    });

    // Add click/touch support for mobile
    gameContainer.addEventListener('click', jump);
    gameContainer.addEventListener('touchstart', (e) => {
      e.preventDefault();
      jump();
    });

    function spawnObstacle() {
      // Only spawn GIF obstacles or new static obstacles
      let useGif = false;
      
      if (gifObstaclesCount < Math.floor((obstacles.length + 1) / 5)) {
        useGif = true;
      } else if (Math.random() < 0.3) { // 30% chance for GIF
        useGif = true;
      }
      
      let obstacle;
      let height, width;
      let randomObstacleIndex = -1; // Initialize for all obstacle types
      
      // Determine if it's night mode
      const period = 300; // Changed from 200 to 300 points per cycle
      const nightStart = 300;
      const inNight = (score >= nightStart) && (Math.floor((score - nightStart) / period) % 2 === 0);
      
      if (useGif) {
        obstacle = document.createElement('img');
        obstacle.src = inNight
          ? 'https://i.postimg.cc/pdFKwfwx/Pixelion-600-x-1000-1.gif'
          : 'https://i.postimg.cc/s2vTvGb0/Pixelion-600-x-1000.gif';
        obstacle.className = 'obstacle gif';
        height = 72; // Fixed height to avoid distortion
        width = 36;  // Fixed width to maintain aspect ratio
        randomObstacleIndex = -1; // GIF obstacles don't have an index
        gifObstaclesCount++;
      } else {
        // Use one of the new obstacle images randomly
        randomObstacleIndex = Math.floor(Math.random() * obstacleImages.length);
        obstacle = document.createElement('img');
        obstacle.src = obstacleImages[randomObstacleIndex];
        obstacle.className = 'obstacle static';
        
        // Fixed sizes to avoid distortion, maintain aspect ratios
        switch(randomObstacleIndex) {
          case 0: // 16.png - Increased by 15%
            height = 55; // Increased from 48 (48 * 1.15 = 55.2 ‚âà 55)
            width = 37;  // Increased from 32 (32 * 1.15 = 36.8 ‚âà 37)
            break;
          case 1: // 15.png - 20% bigger
            height = 48; // 40 * 1.2
            width = 48;  // 40 * 1.2
            break;
          case 2: // Pixelion-7.png - Made bigger
            height = 68; // Increased from 56
            width = 44;  // Increased from 36
            break;
          case 3: // 17.png - Increased by 15%
            height = 51; // Increased from 44 (44 * 1.15 = 50.6 ‚âà 51)
            width = 32;  // Increased from 28 (28 * 1.15 = 32.2 ‚âà 32)
            break;
          default:
            height = 48;
            width = 32;
        }
      }
      
      // Align obstacle spawn with ground dashes
      const dashWidth = 12;
      const dashSpacing = 12;
      const patternLength = dashWidth + dashSpacing;
      const offsetAlign = groundOffset % patternLength;
      const spawnX = gameContainer.offsetWidth + offsetAlign;
      
      // Safety check: don't spawn if it would create impossible situation with scissors
      if (!isObstacleSafe(spawnX, width)) {
        return; // Skip spawning this obstacle
      }
      
      obstacle.style.left = spawnX + 'px';
      
      // Position obstacles based on type
      if (randomObstacleIndex === -1) {
        // GIF obstacles - lowered by 3 pixels (was groundY - 6, now groundY - 9)
        obstacle.style.bottom = (groundY - 9) + 'px';
      } else if (randomObstacleIndex === 0) {
        // Obstacle 1 (16.png) - lowered by 10 pixels (was groundY - 6, now groundY - 16)
        obstacle.style.bottom = (groundY - 16) + 'px';
      } else if (randomObstacleIndex === 1) {
        // Obstacle 2 (15.png) - moved down 3 pixels (was groundY - 3, now groundY - 6)
        obstacle.style.bottom = (groundY - 6) + 'px';
      } else if (randomObstacleIndex === 2) {
        // Obstacle 3 (Pixelion-7.png) - much more forgiving hitbox (90% X, 90% Y margins) + upper 50% removed
        obstacle.style.bottom = groundY + 'px';
        obstacle.style.transform = 'translateY(' + (height * 0.3) + 'px)';
      } else if (randomObstacleIndex === 3) {
        // Obstacle 4 (17.png) - lowered by 10 pixels (was groundY - 6, now groundY - 16)
        obstacle.style.bottom = (groundY - 16) + 'px';
      } else {
        // Fallback for any other obstacles - position on ground
        obstacle.style.bottom = groundY + 'px';
      }
      
      obstacle.style.height = height + 'px';
      obstacle.style.width = width + 'px';
      obstacle.style.objectFit = 'contain'; // Prevent distortion
      obstacle.style.imageRendering = 'pixelated';
      obstacle.style.zIndex = 4; // Above road, below main character
      
      // Add error handling for image loading
      obstacle.onerror = function() {
        console.warn('Failed to load obstacle image:', this.src);
        // Remove the obstacle from DOM if it fails to load
        if (this.parentNode) {
          this.parentNode.removeChild(this);
        }
      };
      
      gameContainer.appendChild(obstacle);
      obstacles.push({ el: obstacle, x: spawnX, width, height, obstacleIndex: randomObstacleIndex, cleared: false });
    }

    function checkCollision(obs) {
      if (!obs || !obs.el) return false;
      
      // Landing grace period - don't check collisions for 25ms after landing
      if (landingGracePeriod > 0) return false;
      
      const playerRect = {
        x: 60,
        y: playerY,
        width: playerSize,
        height: playerSize
      };
      
      // Safety check: only check collision if obstacle is close to player horizontally
      const horizontalDistance = Math.abs(obs.x - playerRect.x);
      
      // Extra safety for obstacle 3 due to its complex positioning
      const safetyDistance = (typeof obs.obstacleIndex === 'number' && obs.obstacleIndex === 2) ? 60 : 80;
      
      if (horizontalDistance > safetyDistance) { // Only check when very close
        return false;
      }
      
      let obsRect = {
        x: obs.x,
        y: groundY,
        width: obs.width,
        height: obs.height
      };
      
      // Standardized forgiving hitboxes for consistent gameplay
      let marginX, marginY;
      
      if (obs.el.classList.contains('gif') &&
          (obs.el.src.includes('s2vTvGb0/Pixelion-600-x-1000.gif') || obs.el.src.includes('pdFKwfwx/Pixelion-600-x-1000-1.gif'))) {
        // GIF obstacles - ultra-restrictive collision only at front-center
        // Only allow collision in a very narrow zone at the front of the obstacle
        const obstacleCenter = obs.x + (obs.width / 2);
        const playerCenter = playerRect.x + (playerRect.width / 2);
        const horizontalDistance = Math.abs(playerCenter - obstacleCenter);
        
        // Only check collision if player is very close to obstacle center (within 20px)
        if (horizontalDistance > 20) {
          return false; // Too far from obstacle center
        }
        
        // Additional check: player must be in front of or overlapping with obstacle front half
        if (playerCenter > obstacleCenter + 10) {
          return false; // Player is behind the center, no collision
        }
        
        // GIF obstacles - account for lowered position (groundY - 9)
        obsRect.y = groundY - 9; // Match the visual position
        
        // Use ultra-small hitbox - 95% margins = 5% size
        marginX = obsRect.width * 0.95;  
        marginY = obsRect.height * 0.95; 
        
        // Use only bottom 20% for collision
        obsRect.height *= 0.2;
      } else if (typeof obs.obstacleIndex === 'number' && obs.obstacleIndex === 1) {
        // Obstacle 2 (15.png) - COMPLETELY REDONE HITBOX to fix landing behind issues
        // Use center-focused collision with ultra-restrictive detection
        const obstacleCenter = obs.x + (obs.width / 2);
        const playerCenter = playerRect.x + (playerRect.width / 2);
        const horizontalDistance = Math.abs(playerCenter - obstacleCenter);
        
        // Only check collision if player is very close to obstacle center (within 25px)
        if (horizontalDistance > 25) {
          return false; // Too far from obstacle center
        }
        
        // Additional check: player must be in front of or overlapping with obstacle front half
        if (playerCenter > obstacleCenter + 15) {
          return false; // Player is behind the center, no collision
        }
        
        // Account for moved down position (groundY - 6)
        obsRect.y = groundY - 6; // Match the visual position
        
        // Use ultra-restrictive hitbox - 90% margins = 10% size (much smaller than before)
        marginX = obsRect.width * 0.9;  
        marginY = obsRect.height * 0.9; 
        
        // Use only bottom 30% for collision to prevent unfair top hits
        obsRect.height *= 0.3;
      } else if (typeof obs.obstacleIndex === 'number' && obs.obstacleIndex === 0) {
        // Obstacle 1 (16.png) - COMPLETELY REDONE HITBOX to fix landing behind issues
        // Use center-focused collision with ultra-restrictive detection
        const obstacleCenter = obs.x + (obs.width / 2);
        const playerCenter = playerRect.x + (playerRect.width / 2);
        const horizontalDistance = Math.abs(playerCenter - obstacleCenter);
        
        // Only check collision if player is very close to obstacle center (within 25px)
        if (horizontalDistance > 25) {
          return false; // Too far from obstacle center
        }
        
        // Additional check: player must be in front of or overlapping with obstacle front half
        if (playerCenter > obstacleCenter + 15) {
          return false; // Player is behind the center, no collision
        }
        
        // Account for lowered position (groundY - 16)
        obsRect.y = groundY - 16; // Match the visual position
        
        // Use ultra-restrictive hitbox - 90% margins = 10% size (much smaller than before)
        marginX = obsRect.width * 0.9;  
        marginY = obsRect.height * 0.9; 
        
        // Use only bottom 30% for collision to prevent unfair top hits
        obsRect.height *= 0.3;
      } else if (typeof obs.obstacleIndex === 'number' && obs.obstacleIndex === 3) {
        // Obstacle 4 (17.png) - account for lowered position (groundY - 16)
        obsRect.y = groundY - 16; // Match the visual position
        marginX = obsRect.width * 0.6;
        marginY = obsRect.height * 0.6;
      } else if (typeof obs.obstacleIndex === 'number' && obs.obstacleIndex === 2) {
        // Obstacle 3 (Pixelion-7.png) - Use obstacle 1's logic with slight Y adjustment
        // Obstacle 1 uses groundY - 16, but obstacle 3 is visually lower due to transform
        // So use a position that's slightly lower than obstacle 1
        obsRect.y = groundY - 10; // Slightly higher than groundY - 16 to account for visual offset
        marginX = obsRect.width * 0.6; // Same as obstacle 1
        marginY = obsRect.height * 0.6; // Same as obstacle 1
      } else {
        // All other obstacles - standard forgiving hitbox (60% margins)
        marginX = obsRect.width * 0.6;
        marginY = obsRect.height * 0.6;
      }
      
      obsRect.x += marginX;
      obsRect.y += marginY;
      obsRect.width = Math.max(0, obsRect.width - 2 * marginX);
      obsRect.height = Math.max(0, obsRect.height - 2 * marginY);
      
      return (
        playerRect.x < obsRect.x + obsRect.width &&
        playerRect.x + playerRect.width > obsRect.x &&
        playerRect.y < obsRect.y + obsRect.height &&
        playerRect.y + playerRect.height > obsRect.y
      );
    }

    function drawStars() {
      if (!starsCtx || !cloudsCtx) return;
      
      // Clear both canvases
      starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
      cloudsCtx.clearRect(0, 0, cloudsCanvas.width, cloudsCanvas.height);
      
      // Determine if it's night mode
      const period = 300; // Changed from 200 to 300 points per cycle
      const nightStart = 300;
      const inNight = (score >= nightStart) && (Math.floor((score - nightStart) / period) % 2 === 0);
      
      // Calculate fade-in for stars 2 seconds before night mode
      let starOpacity = 0;
      if (inNight) {
        starOpacity = 1.0; // Full opacity during night
      } else if (score >= nightStart) {
        // Check if we're approaching night mode (2 seconds before transition)
        const cyclePosition = (score - nightStart) % period;
        const timeUntilNight = period - cyclePosition;
        const scorePerSecond = obstacleSpeed * 0.6; // Approximate score per second
        const secondsUntilNight = timeUntilNight / scorePerSecond;
        
        if (secondsUntilNight <= 2) {
          // Fade in stars over 2 seconds before night transition
          starOpacity = (2 - secondsUntilNight) / 2; // 0 to 1 over 2 seconds
        }
      }
      
      // Draw night stars on the stars canvas (bottom layer) with fade-in effect
      const cachedNightStars = assetCache.get('https://i.postimg.cc/pThkg1gq/18.png');
      if ((inNight || starOpacity > 0) && (cachedNightStars || nightStarsImg.complete)) {
        const imageToUse = cachedNightStars || nightStarsImg;
        try {
          starsCtx.save();
          starsCtx.globalAlpha = starOpacity;
          starsCtx.drawImage(imageToUse, 0, 0, starsCanvas.width, starsCanvas.height);
          starsCtx.restore();
        } catch (e) {
          console.warn('Failed to draw night stars:', e);
        }
      }
      
      // Draw sky overlay (clouds) on the clouds canvas (above stars) - ALWAYS draw during day mode
      const cachedSkyOverlay = assetCache.get('https://i.postimg.cc/Fzz3Jfxz/13-1.png');
      const skyImageAvailable = cachedSkyOverlay || (skyOverlayImg && skyOverlayImg.complete);
      
      if (skyImageAvailable) {
        const imageToUse = cachedSkyOverlay || skyOverlayImg;
        try {
          cloudsCtx.save();
          cloudsCtx.globalAlpha = 0.8;
          cloudsCtx.drawImage(imageToUse, 0, 0, cloudsCanvas.width, cloudsCanvas.height);
          cloudsCtx.restore();
          console.log('‚òÅÔ∏è Clouds drawn successfully');
        } catch (e) {
          console.warn('Failed to draw clouds:', e);
        }
      } else {
        console.warn('‚ö†Ô∏è Sky overlay image not available - cached:', !!cachedSkyOverlay, 'fallback complete:', skyOverlayImg?.complete);
      }
    }

    function generateStars(count = 60) {
      // Remove star generation - we now use image overlays
      stars = [];
    }

    // Draw 8-bit style pixel art ground
    function drawGround() {
      if (!groundCtx) return;
      
      // Asphalt
      groundCtx.clearRect(0, 0, groundCanvas.width, groundCanvas.height);
      groundCtx.fillStyle = '#444';
      groundCtx.fillRect(0, 0, groundCanvas.width, groundCanvas.height);
      
      // Dashes (thinner, smaller, more frequent)
      const dashWidth = 12;
      const dashHeight = 3;
      const dashSpacing = 12;
      
      groundCtx.save();
      groundCtx.globalAlpha = 0.8;
      groundCtx.fillStyle = '#e0e0e0';
      
      for (let x = -groundOffset % (dashWidth + dashSpacing); x < groundCanvas.width; x += dashWidth + dashSpacing) {
        groundCtx.fillRect(Math.round(x), 7, dashWidth, dashHeight);
      }
      
      groundCtx.globalAlpha = 1.0;
      groundCtx.restore();
    }

    // Improved error handling
    window.onerror = function(message, source, lineno, colno, error) {
      console.error('Global error:', message, source, lineno, colno, error);
      // Don't show alert in production, just log
      return false;
    };

    function gameLoop(timestamp) {
      try {
        if (!gameRunning) return;
        
        if (!lastTime) lastTime = timestamp;
        const delta = timestamp - lastTime;
        lastTime = timestamp;
        
        // Cap delta to prevent unfair behavior during lag spikes (max 100ms = ~10fps minimum)
        const cappedDelta = Math.min(delta, 100);

        // Gradually increase speed over time
        obstacleSpeed = Math.min(3 + score * 0.001, 7.0);
        if (speedDisplay) {
          speedDisplay.textContent = '–°–∫–æ—Ä–æ—Å—Ç—å: ' + obstacleSpeed.toFixed(1);
        }

        // Alternate night and day every 300 points, starting at 300
        const period = 300;
        const nightStart = 300;
        const inNight = (score >= nightStart) && (Math.floor((score - nightStart) / period) % 2 === 0);

        if (inNight && !darkMode) {
          // Transitioning to night mode
          gameContainer.classList.add('dark');
          if (nightOverlay) {
            nightOverlay.classList.add('active');
          }
          if (h1) h1.style.color = '#ff69b4';
          if (p) p.style.color = '#ff69b4';
          if (scoreDisplay) scoreDisplay.style.color = '#ff69b4';
          if (highScoreDisplay) highScoreDisplay.style.color = '#ff69b4';
          if (gameOverDisplay) gameOverDisplay.style.color = '#ff69b4';
          darkMode = true;
          if (starsCtx) {
            starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
          }
          if (cloudsCtx) {
            cloudsCtx.clearRect(0, 0, cloudsCanvas.width, cloudsCanvas.height);
          }
        } else if (!inNight && darkMode) {
          // Transitioning to day mode
          gameContainer.classList.remove('dark');
          if (nightOverlay) {
            nightOverlay.classList.remove('active');
          }
          if (h1) h1.style.color = '#ff69b4';
          if (p) p.style.color = '#ff69b4';
          if (scoreDisplay) scoreDisplay.style.color = '#ff69b4';
          if (highScoreDisplay) highScoreDisplay.style.color = '#ff69b4';
          if (gameOverDisplay) gameOverDisplay.style.color = '#ff69b4';
          darkMode = false;
          if (starsCtx) {
            starsCtx.clearRect(0, 0, starsCanvas.width, starsCanvas.height);
          }
          if (cloudsCtx) {
            cloudsCtx.clearRect(0, 0, cloudsCanvas.width, cloudsCanvas.height);
          }
        }
        
        // Always draw stars (for smooth transitions)
        drawStars();

        // Player physics - make frame-rate dependent for consistent timing
        velocityY -= gravity * (cappedDelta / 16.67); // Frame-rate dependent gravity
        playerY += velocityY * (cappedDelta / 16.67);  // Frame-rate dependent movement
        
        // Update landing grace period
        if (landingGracePeriod > 0) {
          landingGracePeriod -= cappedDelta;
        }
        
        if (playerY <= groundY - 11) { // Updated to match new starting position
          playerY = groundY - 11;
          velocityY = 0;
          if (isJumping) {
            isJumping = false;
            landingGracePeriod = 25; // Reduced from 50ms to 25ms for better responsiveness
            updatePlayerSprite(); // Switch back to running when landing
          }
        }
        
        if (player) {
          player.style.bottom = playerY + 'px';
        }

        // Obstacles - only spawn if game is running
        if (gameRunning) {
          obstacleTimer += cappedDelta;
          
          // Increase spawn intervals when scissors are active to prevent overlapping
          const scissorsActivePenalty = scissors.length > 0 ? 1.5 : 1.0;
          const adjustedInterval = nextObstacleInterval * (isSafari ? 1.2 : 1.0) * scissorsActivePenalty;
          
          if (obstacleTimer > adjustedInterval) {
            spawnObstacle();
            obstacleTimer = 0;
            nextObstacleInterval = 1320 + Math.random() * 1080; // random between 1320-2400ms (20% less frequent)
          }
        }
        
        // Use transform for better performance in Safari
        obstacles.forEach(obs => {
          obs.x -= obstacleSpeed * (cappedDelta / 16.67); // Make frame-rate dependent like ground
          if (obs.el) {
            if (isSafari) {
              // Use transform for better Safari performance
              obs.el.style.transform = `translateX(${obs.x}px)`;
            } else {
              obs.el.style.left = obs.x + 'px';
            }
          }
        });
        
        // Safety check: Remove any scissors that are now too close to obstacles
        // This prevents impossible situations that could occur due to timing
        for (let i = scissors.length - 1; i >= 0; i--) {
          const sc = scissors[i];
          let tooClose = false;
          
          for (const obs of obstacles) {
            const horizontalDistance = Math.abs(sc.x - obs.x);
            const playerInteractionZone = 150; // Reduced from 200 to be less aggressive
            
            if (horizontalDistance < playerInteractionZone) {
              // Check if this creates an impossible scenario
              const playerMeetsObstacle = obs.x - 60;
              const playerMeetsScissors = sc.x - 60;
              
              if (Math.abs(playerMeetsObstacle - playerMeetsScissors) < 100) { // Reduced from 150 to 100
                tooClose = true;
                break;
              }
            }
          }
          
          if (tooClose) {
            // Remove the scissors to prevent impossible situation
            if (sc.el && sc.el.parentNode) {
              sc.el.remove();
            }
            scissors.splice(i, 1);
          }
        }

        // Original obstacle collision and cleanup logic
        for (let i = obstacles.length - 1; i >= 0; i--) {
          const obs = obstacles[i];
          if (!obs || !obs.el) {
            obstacles.splice(i, 1);
            continue;
          }
          
          if (checkCollision(obs)) {
            resetStreak(); // Reset streak on collision
            endGame();
            return;
          }
          
          // Check if obstacle was cleared (passed the player)
          if (obs.x + obs.width < 60 && !obs.cleared) { // Player is at x=60
            obs.cleared = true; // Mark as cleared to avoid multiple triggers
            handleObstacleClear(obs);
          }
          
          if (obs.x + obs.width < 0) {
            if (obs.el && obs.el.parentNode) {
              obs.el.remove();
            }
            obstacles.splice(i, 1);
          }
        }

        // Spawn scissors (birds) after score 200, with random interval
        if (score >= 200 && gameRunning) {
          scissorsTimer += cappedDelta;
          if (scissorsTimer > nextScissorsInterval) {
            spawnScissors();
            scissorsTimer = 0;
          }
        }
        updateScissors(cappedDelta);

        // Score
        score += cappedDelta * 0.01;
        if (scoreDisplay) {
          scoreDisplay.textContent = '–°—á—ë—Ç: ' + Math.floor(score);
        }
        
        // Update high score if current score is higher
        updateHighScore(score);

        // Move ground offset with the same speed as obstacles (frame-rate dependent)
        groundOffset += obstacleSpeed * (cappedDelta / 16.67); // Normalize to 60fps (16.67ms per frame)
        if (groundOffset > 24) groundOffset -= 24; // Match dash pattern length (12+12=24)
        drawGround();

        if (!isGameOver && gameRunning) {
          animationId = requestAnimationFrame(gameLoop);
        }
      } catch (e) {
        console.error('Game loop error:', e);
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
        isGameOver = true;
        gameRunning = false;
        if (gameOverDisplay) {
          gameOverDisplay.style.display = 'block';
        }
      }
    }

    function endGame() {
      if (isGameOver) return; // Prevent multiple calls
      isGameOver = true;
      gameRunning = false;
      
      // Change player to jumping image and start flicker effect
      if (player) {
        player.src = playerJumpingImg;
        player.style.opacity = '1';
        
        // Start flicker animation - toggle between 100% and 50% opacity every 0.3 seconds
        flickerInterval = setInterval(() => {
          if (!player) return; // Safety check in case player element is removed
          if (player.style.opacity === '0.5') {
            player.style.opacity = '1';
          } else {
            player.style.opacity = '0.5';
          }
        }, 300);
      }
      
      if (gameOverDisplay) {
        gameOverDisplay.style.display = 'block';
      }
      
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
      
      stopBackgroundMusic();
      
      if (soundsOn && loseSound) {
        try {
          loseSound.currentTime = 0;
          loseSound.play().then(() => {
            loseSound.onended = function() {
              if (soundOn) {
                startBackgroundMusic();
              }
              loseSound.onended = null; // Reset handler
            };
          }).catch(e => {
            console.warn('Could not play lose sound:', e);
            if (soundOn) {
              startBackgroundMusic();
            }
          });
        } catch (e) {
          console.warn('Lose sound error:', e);
          if (soundOn) {
            startBackgroundMusic();
          }
        }
      } else {
        if (soundOn) {
          startBackgroundMusic();
        }
      }
    }

    window.restartGame = function() {
      try {
        localStorage.setItem('musicOn', soundOn ? 'true' : 'false');
      } catch (e) {
        console.warn('Could not save to localStorage:', e);
      }
      
      // Use resetGame() instead of location.reload() to preserve asset cache
      stopBackgroundMusic();
      resetGame();
      
      // Ensure clouds are drawn immediately on restart
      setTimeout(() => {
        drawStars();
        console.log('üîÑ Game restarted - clouds redrawn');
      }, 100);
    };

    // Optimized asset loading with prioritization
    const criticalAssets = [
      'https://i.postimg.cc/dtBqYwh3/Pixelion.png', // Standing player
      'https://i.postimg.cc/DyDdLcHT/ezgif-com-optimize.gif', // Running player
      'https://i.postimg.cc/GpBrGDqT/Pixelion-2.png', // Jumping player
    ];
    
    const gameplayAssets = [
      'https://i.postimg.cc/vHNFnpGZ/16.png', // Obstacle 1
      'https://i.postimg.cc/8CLqqcM7/15.png', // Obstacle 2
      'https://i.postimg.cc/85DqDGmt/Pixelion-7.png', // Obstacle 3
      'https://i.postimg.cc/FzwprgQN/17.png', // Obstacle 4
      'https://i.postimg.cc/s2vTvGb0/Pixelion-600-x-1000.gif', // GIF obstacle day
    ];
    
    const enhancementAssets = [
      'https://i.postimg.cc/pdFKwfwx/Pixelion-600-x-1000-1.gif', // GIF obstacle night
      'https://i.postimg.cc/NM6G70K8/ezgif-com-animated-gif-maker.gif', // Scissors
      'https://i.postimg.cc/Fzz3Jfxz/13-1.png', // Sky overlay (clouds)
      'https://i.postimg.cc/pThkg1gq/18.png', // Night stars
    ];
    
    const audioAssets = [
      { url: 'https://dl.dropboxusercontent.com/scl/fi/ezrm6z3cx6zia9ski74nd/retro-jump-1-236684.mp3?rlkey=cbxvo5jhokcw9f68d4plxeuuf&st=b95r8mro', critical: true }, // Jump sound
      { url: 'https://dl.dropboxusercontent.com/scl/fi/03ewjm0np47rvxwvkw4fr/080047_lose_funny_retro_video-game-80925.mp3?rlkey=f5sz95h1alf549ppriqkv7ees&st=8t37iozp', critical: false }, // Lose sound
      { url: 'https://dl.dropboxusercontent.com/scl/fi/u8vy9c7rk8uh86l4iy2ef/Swan-Lake-Theme.mp3?rlkey=c9gl4gd9i4jy5f25esiqd1ra3&st=jla22prl', critical: false }, // Background music
    ];

    let assetsLoaded = {
      critical: 0,
      gameplay: 0,
      enhancement: 0,
      audio: 0
    };

    // Asset cache for better performance
    const assetCache = new Map();
    let totalLoadTime = 0;

    function loadAssetWithTimeout(url, type = 'image', timeout = 5000, priority = 'auto') {
      // Return cached asset if available
      if (assetCache.has(url)) {
        return Promise.resolve(assetCache.get(url));
      }

      return new Promise((resolve) => {
        let asset;
        let timer;
        const startTime = performance.now();
        
        const cleanup = (success = true) => {
          if (timer) clearTimeout(timer);
          const loadTime = performance.now() - startTime;
          totalLoadTime += loadTime;
          
          if (success && asset) {
            assetCache.set(url, asset);
          }
          resolve(asset); // Always resolve
        };
        
        timer = setTimeout(() => {
          console.warn(`Asset load timeout: ${url} (${timeout}ms)`);
          cleanup(false);
        }, timeout);
        
        if (type === 'image') {
          asset = new Image();
          asset.crossOrigin = 'anonymous'; // Better caching
          asset.decoding = 'async'; // Non-blocking decoding
          asset.loading = 'eager'; // High priority loading
          
          asset.onload = () => cleanup(true);
          asset.onerror = () => cleanup(false);
          asset.src = url;
        } else if (type === 'audio') {
          asset = new Audio();
          asset.crossOrigin = 'anonymous';
          asset.preload = priority === 'critical' ? 'auto' : 'metadata';
          
          asset.oncanplaythrough = () => cleanup(true);
          asset.onerror = () => cleanup(false);
          asset.src = url;
        }
      });
    }

    async function fastPreloadAssets(onProgress) {
      const startTime = performance.now();
      let assetsProgress = { critical: 0, gameplay: 0, enhancement: 0, audio: 0 };
      
      // Phase 1: Load critical assets with highest priority
      console.log('üöÄ Loading critical assets...');
      const criticalPromises = criticalAssets.map((url, index) => 
        loadAssetWithTimeout(url, 'image', 2000, 'critical').then(asset => {
          assetsProgress.critical++;
          loadedAssets++;
          updateLoadingProgress(loadedAssets, totalAssets, `–ó–∞–≥—Ä—É–∑–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ—Å—É—Ä—Å–æ–≤... (${assetsProgress.critical}/${criticalAssets.length})`);
          console.log(`‚úì Critical asset ${assetsProgress.critical}/${criticalAssets.length}: ${url.split('/').pop()}`);
          return asset;
        })
      );
      
      await Promise.all(criticalPromises);
      assetsLoaded.critical = criticalAssets.length;
      console.log(`‚úÖ Critical assets loaded in ${Math.round(performance.now() - startTime)}ms`);
      
      // Start game immediately with critical assets
      onProgress('critical');
      
      // Phase 2: Load gameplay assets in parallel
      console.log('üéÆ Loading gameplay assets...');
      const gameplayPromises = gameplayAssets.map((url, index) => 
        loadAssetWithTimeout(url, 'image', 3000, 'gameplay').then(asset => {
          assetsProgress.gameplay++;
          loadedAssets++;
          updateLoadingProgress(loadedAssets, totalAssets, `–ó–∞–≥—Ä—É–∑–∫–∞ –∏–≥—Ä–æ–≤—ã—Ö —Ä–µ—Å—É—Ä—Å–æ–≤... (${assetsProgress.gameplay}/${gameplayAssets.length})`);
          console.log(`‚úì Gameplay asset ${assetsProgress.gameplay}/${gameplayAssets.length}: ${url.split('/').pop()}`);
          return asset;
        })
      );
      
      // Phase 3: Load critical audio in parallel
      const criticalAudio = audioAssets.filter(a => a.critical);
      const audioPromises = criticalAudio.map(a => 
        loadAssetWithTimeout(a.url, 'audio', 2500, 'critical').then(asset => {
          assetsProgress.audio++;
          loadedAssets++;
          updateLoadingProgress(loadedAssets, totalAssets, '–ó–∞–≥—Ä—É–∑–∫–∞ –∑–≤—É–∫–æ–≤...');
          console.log(`üîä Critical audio loaded: ${a.url.split('/').pop()}`);
          return asset;
        })
      );
      
      // Wait for gameplay assets and critical audio
      await Promise.all([...gameplayPromises, ...audioPromises]);
      assetsLoaded.gameplay = gameplayAssets.length;
      assetsLoaded.audio = criticalAudio.length;
      console.log(`‚úÖ Gameplay assets loaded in ${Math.round(performance.now() - startTime)}ms`);
      
      onProgress('gameplay');
      
      // Phase 4: Load enhancement assets in background (non-blocking)
      console.log('üåü Loading enhancement assets in background...');
      const enhancementPromises = enhancementAssets.map(url => 
        loadAssetWithTimeout(url, 'image', 5000, 'enhancement').then(asset => {
          assetsProgress.enhancement++;
          loadedAssets++;
          updateLoadingProgress(loadedAssets, totalAssets, `–ó–∞–≥—Ä—É–∑–∫–∞ –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–π... (${assetsProgress.enhancement}/${enhancementAssets.length})`);
          console.log(`üé® Enhancement asset ${assetsProgress.enhancement}/${enhancementAssets.length}: ${url.split('/').pop()}`);
          return asset;
        })
      );
      
      const nonCriticalAudio = audioAssets.filter(a => !a.critical);
      const bgAudioPromises = nonCriticalAudio.map(a => 
        loadAssetWithTimeout(a.url, 'audio', 6000, 'enhancement').then(asset => {
          assetsProgress.audio++;
          loadedAssets++;
          updateLoadingProgress(loadedAssets, totalAssets, '–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–æ–Ω–æ–≤–æ–π –º—É–∑—ã–∫–∏...');
          console.log(`üéµ Background audio loaded: ${a.url.split('/').pop()}`);
          return asset;
        })
      );
      
      // Don't wait for these - load in background
      Promise.all([...enhancementPromises, ...bgAudioPromises]).then(() => {
        assetsLoaded.enhancement = enhancementAssets.length;
        assetsLoaded.audio += nonCriticalAudio.length;
        const totalTime = Math.round(performance.now() - startTime);
        console.log(`üéâ All assets loaded in ${totalTime}ms`);
        console.log(`üìä Total asset load time: ${Math.round(totalLoadTime)}ms`);
        console.log(`üèÜ Cache hits: ${assetCache.size} assets cached`);
        console.log(`‚ö° Loading efficiency: ${Math.round((totalLoadTime / totalTime) * 100)}% utilization`);
        onProgress('complete');
      });
      
      console.log(`‚ö° Fast loading complete in ${Math.round(performance.now() - startTime)}ms`);
    }

    // Hide game UI until loaded
    const loadingDiv = document.getElementById('loading');
    const gameContainerDiv = document.getElementById('gameContainer');
    const playerElement = document.getElementById('player');
    const loadingBar = document.getElementById('loadingBar');
    const loadingText = document.getElementById('loadingText');
    const loadingStatus = document.getElementById('loadingStatus');

    // Calculate total assets for progress tracking
    const totalAssets = criticalAssets.length + gameplayAssets.length + enhancementAssets.length + audioAssets.length;
    let loadedAssets = 0;

    // Update loading progress
    function updateLoadingProgress(loadedCount, totalCount, status) {
      const percentage = Math.round((loadedCount / totalCount) * 100);
      
      if (loadingBar) {
        loadingBar.style.width = percentage + '%';
      }
      
      if (loadingText) {
        loadingText.textContent = percentage + '%';
      }
      
      if (loadingStatus && status) {
        loadingStatus.textContent = status;
      }
    }

    // Update loading text with progress
    function updateLoadingText(phase) {
      if (!loadingDiv) return;
      
      switch(phase) {
        case 'critical':
          updateLoadingProgress(criticalAssets.length, totalAssets, '–ò–≥—Ä–∞ –≥–æ—Ç–æ–≤–∞! –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞...');
          setTimeout(() => {
            if (loadingDiv) {
              loadingDiv.style.display = 'none';
            }
          }, 500); // Brief delay to show completion
          break;
        case 'gameplay':
          const gameplayLoaded = criticalAssets.length + gameplayAssets.length + audioAssets.filter(a => a.critical).length;
          updateLoadingProgress(gameplayLoaded, totalAssets, '–ó–∞–≥—Ä—É–∑–∫–∞ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞...');
          break;
        case 'complete':
          updateLoadingProgress(totalAssets, totalAssets, '–ó–∞–≥—Ä—É–∑–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!');
          break;
      }
    }

    // Initialize the game with fast loading
    fastPreloadAssets((phase) => {
      if (phase === 'critical') {
        // Game can start with just critical assets
        console.log('üéÆ Starting game with critical assets...');
        
        // Performance monitoring
        if (performance.mark) {
          performance.mark('game-ready');
        }
        
        if (loadingDiv) {
          loadingDiv.style.display = 'none';
        }
        
        initializeAudio();
        resetGame();
        
        // Ensure player is visible immediately
        if (playerElement) {
          playerElement.style.display = 'block';
          playerElement.style.visibility = 'visible';
          playerElement.style.position = 'absolute';
          playerElement.style.left = '60px';
          playerElement.style.bottom = playerY + 'px';
          playerElement.style.width = '72px';
          playerElement.style.height = '72px';
          playerElement.style.zIndex = '5';
          console.log('‚úÖ Player ready:', playerElement.style.left, playerElement.style.bottom);
        }
      } else if (phase === 'gameplay') {
        console.log('üéØ Gameplay assets ready - full game functionality available');
        updateLoadingText(phase);
        
        if (performance.mark) {
          performance.mark('gameplay-ready');
        }
      } else if (phase === 'complete') {
        console.log('üèÜ All assets loaded - premium experience ready');
        updateLoadingText(phase);
        
        if (performance.mark) {
          performance.mark('all-assets-loaded');
          performance.measure('loading-time', 'navigationStart', 'all-assets-loaded');
        }
        
        // Cache performance report
        if (console.table && assetCache.size > 0) {
          console.log('üìä Loading Performance Report:');
          console.table({
            'Total Assets': totalAssets,
            'Cached Assets': assetCache.size,
            'Cache Hit Rate': Math.round((assetCache.size / totalAssets) * 100) + '%',
            'Load Time': Math.round(totalLoadTime) + 'ms'
          });
        }
      }
    }).catch(error => {
      console.error('‚ùå Asset loading failed:', error);
      // Fallback: try to start game anyway
      if (loadingDiv) {
        loadingDiv.innerHTML = '<div style="color:#ff4444;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏, –ø—Ä–æ–±—É–µ–º –∑–∞–ø—É—Å—Ç–∏—Ç—å...</div>';
      }
      setTimeout(() => {
        if (loadingDiv) loadingDiv.style.display = 'none';
        initializeAudio();
        resetGame();
      }, 1000);
    });

    // Improved audio initialization with error handling
    function initializeAudio() {
      try {
        // Don't auto-play on load - wait for user interaction
        gameMusic.volume = 0.7;
        loseSound.volume = 0.8;
        jumpSound.volume = 0.6;
      } catch (e) {
        console.warn('Audio initialization error:', e);
      }
    }
  </script>
</body>
</html>